/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Tencent is pleased to support the open source community by making tgfx available.
//
//  Copyright (C) 2025 Tencent. All rights reserved.
//
//  Licensed under the BSD 3-Clause License (the "License"); you may not use this file except
//  in compliance with the License. You may obtain a copy of the License at
//
//      https://opensource.org/licenses/BSD-3-Clause
//
//  unless required by applicable law or agreed to in writing, software distributed under the
//  license is distributed on an "as is" basis, without warranties or conditions of any kind,
//  either express or implied. see the license for the specific language governing permissions
//  and limitations under the license.
//
/////////////////////////////////////////////////////////////////////////////////////////////////

#include "OpsCompositor.h"
#include "core/Atlas.h"
#include "core/PathRasterizer.h"
#include "core/PathRef.h"
#include "core/PathTriangulator.h"
#include "core/utils/RectToRectMatrix.h"
#include "core/utils/Types.h"
#include "gpu/DrawingManager.h"
#include "gpu/ProxyProvider.h"
#include "gpu/ops/AtlasTextOp.h"
#include "gpu/ops/ClearOp.h"
#include "gpu/ops/ShapeDrawOp.h"
#include "gpu/processors/AARectEffect.h"
#include "gpu/processors/DeviceSpaceTextureEffect.h"
#include "processors/PorterDuffXferProcessor.h"

namespace tgfx {
/**
 * Defines the maximum distance a draw can extend beyond a clip's boundary and still be considered
 * 'on the other side'. This tolerance accounts for potential floating point rounding errors. The
 * value of 1e-3 is chosen because, in the coverage case, as long as coverage stays within
 * 0.5 * 1/256 of its intended value, it shouldn't affect the final pixel values.
 */
static constexpr float BOUNDS_TOLERANCE = 1e-3f;

static bool AnyRectHasUniqueColor(const std::vector<PlacementPtr<RectRecord>>& rects) {
  if (rects.size() <= 1) {
    return false;
  }
  bool hasColor = false;
  auto& firstColor = rects.front()->color;
  for (auto& record : rects) {
    if (record->color != firstColor) {
      hasColor = true;
      break;
    }
  }
  return hasColor;
}

static bool AnyRectHasUniqueMatrix(const std::vector<PlacementPtr<RectRecord>>& rects) {
  if (rects.empty()) {
    return false;
  }
  if (rects.size() == 1) {
    return rects.front()->rect != rects.front()->uvRect;
  }
  bool hasUVCoord = false;
  auto& firstMatrix = rects.front()->viewMatrix;
  for (auto& record : rects) {
    if (record->viewMatrix != firstMatrix || record->rect != record->uvRect) {
      hasUVCoord = true;
      break;
    }
  }
  return hasUVCoord;
}

OpsCompositor::OpsCompositor(std::shared_ptr<RenderTargetProxy> proxy, uint32_t renderFlags)
    : context(proxy->getContext()), renderTarget(std::move(proxy)), renderFlags(renderFlags) {
  DEBUG_ASSERT(renderTarget != nullptr);
}

void OpsCompositor::fillImage(std::shared_ptr<Image> image, const SamplingOptions& sampling,
                              const MCState& state, const Fill& fill) {
  DEBUG_ASSERT(image != nullptr);
  auto imageRect = Rect::MakeWH(image->width(), image->height());
  if (!canAppend(PendingOpType::Image, state.clip, fill) || pendingImage != image ||
      pendingSampling != sampling || pendingConstraint != SrcRectConstraint::Fast) {
    flushPendingOps(PendingOpType::Image, state.clip, fill);
    pendingImage = std::move(image);
    pendingSampling = sampling;
    pendingConstraint = SrcRectConstraint::Fast;
  }
  auto record =
      drawingBuffer()->make<RectRecord>(imageRect, state.matrix, fill.color.premultiply());
  pendingRects.emplace_back(std::move(record));
}

void OpsCompositor::fillImageRect(std::shared_ptr<Image> image, const Rect& srcRect,
                                  const Rect& dstRect, const SamplingOptions& sampling,
                                  const MCState& state, const Fill& fill,
                                  SrcRectConstraint constraint) {
  DEBUG_ASSERT(image != nullptr);
  DEBUG_ASSERT(!srcRect.isEmpty());
  DEBUG_ASSERT(!dstRect.isEmpty());
  auto fillInLocal = fill.makeWithMatrix(MakeRectToRectMatrix(dstRect, srcRect));
  if (!canAppend(PendingOpType::Image, state.clip, fillInLocal) || pendingImage != image ||
      pendingSampling != sampling || pendingConstraint != constraint) {
    flushPendingOps(PendingOpType::Image, state.clip, fillInLocal);
    pendingImage = std::move(image);
    pendingSampling = sampling;
    pendingConstraint = constraint;
  }
  auto record = drawingBuffer()->make<RectRecord>(dstRect, state.matrix,
                                                  fillInLocal.color.premultiply(), &srcRect);
  pendingRects.emplace_back(std::move(record));
}

void OpsCompositor::fillRect(const Rect& rect, const MCState& state, const Fill& fill) {
  DEBUG_ASSERT(!rect.isEmpty());
  if (!canAppend(PendingOpType::Rect, state.clip, fill)) {
    flushPendingOps(PendingOpType::Rect, state.clip, fill);
  }
  auto record = drawingBuffer()->make<RectRecord>(rect, state.matrix, fill.color.premultiply());
  pendingRects.emplace_back(std::move(record));
}

void OpsCompositor::drawRRect(const RRect& rRect, const MCState& state, const Fill& fill,
                              const Stroke* stroke) {
  DEBUG_ASSERT(!rRect.rect.isEmpty());
  auto rectFill = fill.makeWithMatrix(state.matrix);
  if (!canAppend(PendingOpType::RRect, state.clip, rectFill) ||
      (pendingStrokes.empty() != (stroke == nullptr))) {
    flushPendingOps(PendingOpType::RRect, state.clip, rectFill);
  }
  auto record =
      drawingBuffer()->make<RRectRecord>(rRect, state.matrix, rectFill.color.premultiply());
  pendingRRects.emplace_back(std::move(record));
  if (stroke) {
    auto strokeRecord = drawingBuffer()->make<Stroke>(*stroke);
    pendingStrokes.emplace_back(std::move(strokeRecord));
  }
}

static Rect ToLocalBounds(const Rect& bounds, const Matrix& viewMatrix) {
  Matrix invertMatrix = {};
  if (!viewMatrix.invert(&invertMatrix)) {
    return {};
  }
  auto localBounds = bounds;
  invertMatrix.mapRect(&localBounds);
  return localBounds;
}

static Rect ClipLocalBounds(const Rect& localBounds, const Matrix& viewMatrix,
                            const Rect& clipBounds) {
  auto result = ToLocalBounds(clipBounds, viewMatrix);
  if (!result.intersect(localBounds)) {
    return {};
  }
  return result;
}

void OpsCompositor::fillShape(std::shared_ptr<Shape> shape, const MCState& state,
                              const Fill& fill) {
  DEBUG_ASSERT(shape != nullptr);
  flushPendingOps();
  Matrix uvMatrix = {};
  if (!state.matrix.invert(&uvMatrix)) {
    return;
  }
  std::optional<Rect> localBounds = std::nullopt;
  std::optional<Rect> deviceBounds = std::nullopt;
  float drawScale = 1.0f;
  auto [needLocalBounds, needDeviceBounds] = needComputeBounds(fill, true);
  auto& clip = state.clip;
  auto clipBounds = getClipBounds(clip);
  if (needLocalBounds) {
    if (shape->isInverseFillType()) {
      localBounds = ToLocalBounds(clipBounds, state.matrix);
    } else {
      localBounds = shape->getBounds();
      localBounds = ClipLocalBounds(*localBounds, state.matrix, clipBounds);
    }
    drawScale = std::min(state.matrix.getMaxScale(), 1.0f);
  }
  shape = Shape::ApplyMatrix(std::move(shape), state.matrix);
  if (needDeviceBounds) {
    deviceBounds = shape->isInverseFillType() ? clipBounds : shape->getBounds();
  }
  auto aaType = getAAType(fill);
  auto shapeProxy = proxyProvider()->createGPUShapeProxy(shape, aaType, clipBounds, renderFlags);
  auto drawOp =
      ShapeDrawOp::Make(std::move(shapeProxy), fill.color.premultiply(), uvMatrix, aaType);
  addDrawOp(std::move(drawOp), clip, fill, localBounds, deviceBounds, drawScale);
}

void OpsCompositor::discardAll() {
  ops.clear();
  if (pendingType != PendingOpType::Unknown) {
    resetPendingOps();
  }
}

void OpsCompositor::resetPendingOps(PendingOpType type, Path clip, Fill fill) {
  pendingType = type;
  pendingClip = std::move(clip);
  pendingFill = std::move(fill);
  pendingImage = nullptr;
  pendingSampling = {};
  pendingConstraint = SrcRectConstraint::Fast;
  pendingRects.clear();
  pendingRRects.clear();
  pendingStrokes.clear();
  pendingAtlasTexture = nullptr;
}

bool OpsCompositor::CompareFill(const Fill& a, const Fill& b) {
  // Ignore the color differences.
  if (a.antiAlias != b.antiAlias || a.blendMode != b.blendMode) {
    return false;
  }
  if (a.shader != b.shader) {
    if (!a.shader || !b.shader || !a.shader->isEqual(b.shader.get())) {
      return false;
    }
  }
  if (a.maskFilter != b.maskFilter) {
    if (!a.maskFilter || !b.maskFilter || !a.maskFilter->isEqual(b.maskFilter.get())) {
      return false;
    }
  }
  if (a.colorFilter != b.colorFilter) {
    if (!a.colorFilter || !b.colorFilter || !a.colorFilter->isEqual(b.colorFilter.get())) {
      return false;
    }
  }
  return true;
}

bool OpsCompositor::canAppend(PendingOpType type, const Path& clip, const Fill& fill) const {
  if (pendingType != type || !pendingClip.isSame(clip) || !CompareFill(pendingFill, fill)) {
    return false;
  }
  switch (pendingType) {
    case PendingOpType::Rect:
    case PendingOpType::Image:
    case PendingOpType::Atlas:
      return pendingRects.size() < RectDrawOp::MaxNumRects;
    case PendingOpType::RRect:
      return pendingRRects.size() < RRectDrawOp::MaxNumRRects;
    default:
      break;
  }
  return true;
}

/**
 * Returns true if the given rect counts as aligned with pixel boundaries.
 */
static bool IsPixelAligned(const Rect& rect) {
  return fabsf(roundf(rect.left) - rect.left) <= BOUNDS_TOLERANCE &&
         fabsf(roundf(rect.top) - rect.top) <= BOUNDS_TOLERANCE &&
         fabsf(roundf(rect.right) - rect.right) <= BOUNDS_TOLERANCE &&
         fabsf(roundf(rect.bottom) - rect.bottom) <= BOUNDS_TOLERANCE;
}

static bool RRectUseScale(Context* context) {
  return !context->caps()->floatIs32Bits;
}

class PendingOpsAutoReset {
 public:
  PendingOpsAutoReset(OpsCompositor* compositor, PendingOpType type, Path clip, Fill fill)
      : compositor(compositor), type(type), clip(std::move(clip)), fill(std::move(fill)) {
  }

  ~PendingOpsAutoReset() {
    compositor->resetPendingOps(type, std::move(clip), std::move(fill));
  }

 private:
  OpsCompositor* compositor;
  PendingOpType type;
  Path clip;
  Fill fill;
};

void OpsCompositor::flushPendingOps(PendingOpType type, Path clip, Fill fill) {
  if (pendingType == PendingOpType::Unknown) {
    if (type != PendingOpType::Unknown) {
      pendingType = type;
      pendingClip = std::move(clip);
      pendingFill = std::move(fill);
    }
    return;
  }
  PendingOpsAutoReset autoReset(this, type, std::move(clip), std::move(fill));
  PlacementPtr<DrawOp> drawOp = nullptr;
  std::optional<Rect> localBounds = std::nullopt;
  std::optional<Rect> deviceBounds = std::nullopt;
  std::optional<float> drawScale = std::nullopt;
  bool hasCoverage = pendingFill.maskFilter != nullptr || !pendingClip.isEmpty() ||
                     pendingClip.isInverseFillType();
  bool hasImageFill = pendingType == PendingOpType::Image || pendingType == PendingOpType::Atlas;
  auto [needLocalBounds, needDeviceBounds] =
      needComputeBounds(pendingFill, hasCoverage, hasImageFill);
  auto aaType = getAAType(pendingFill);
  Rect clipBounds = {};
  if (needLocalBounds) {
    clipBounds = getClipBounds(pendingClip);
    localBounds = Rect::MakeEmpty();
    drawScale = 0.0f;
  }

  if (needLocalBounds || needDeviceBounds) {
    if (pendingType == PendingOpType::RRect) {
      deviceBounds = Rect::MakeEmpty();
      for (auto& record : pendingRRects) {
        auto rect = record->viewMatrix.mapRect(record->rRect.rect);
        deviceBounds->join(rect);
        drawScale = std::max(*drawScale, record->viewMatrix.getMaxScale());
      }
      localBounds = deviceBounds;
      if (!localBounds->intersect(clipBounds)) {
        localBounds->setEmpty();
      }
    } else {
      if (needLocalBounds) {
        for (auto& rect : pendingRects) {
          auto localViewMatrix = rect->viewMatrix;
          localViewMatrix.preConcat(MakeRectToRectMatrix(rect->uvRect, rect->rect));
          localBounds->join(ClipLocalBounds(rect->uvRect, localViewMatrix, clipBounds));
          drawScale = std::max(*drawScale, localViewMatrix.getMaxScale());
        }
      }
      if (needDeviceBounds) {
        deviceBounds = Rect::MakeEmpty();
        for (auto& record : pendingRects) {
          auto rect = record->viewMatrix.mapRect(record->rect);
          deviceBounds->join(rect);
        }
      }
    }
    if (localBounds.has_value() && localBounds->isEmpty()) {
      return;
    }
  }

  switch (pendingType) {
    case PendingOpType::Rect:
      if (pendingRects.size() == 1) {
        auto& paint = pendingRects.front();
        if (drawAsClear(paint->rect, {paint->viewMatrix, pendingClip}, pendingFill)) {
          return;
        }
      }
    // fallthrough
    case PendingOpType::Image: {
      auto subsetMode = RectsVertexProvider::UVSubsetMode::None;
      if (pendingConstraint == SrcRectConstraint::Strict && pendingImage) {
        subsetMode = pendingSampling.filterMode == FilterMode::Linear
                         ? RectsVertexProvider::UVSubsetMode::SubsetOnly
                         : RectsVertexProvider::UVSubsetMode::RoundOutAndSubset;
      }
      bool hasColor = AnyRectHasUniqueColor(pendingRects);
      bool hasUVCoord = AnyRectHasUniqueMatrix(pendingRects);
      auto provider = RectsVertexProvider::MakeFrom(drawingBuffer(), std::move(pendingRects),
                                                    aaType, hasColor, hasUVCoord, subsetMode);
      drawOp = RectDrawOp::Make(context, std::move(provider), renderFlags);
    } break;
    case PendingOpType::RRect: {
      auto provider =
          RRectsVertexProvider::MakeFrom(drawingBuffer(), std::move(pendingRRects), aaType,
                                         RRectUseScale(context), std::move(pendingStrokes));
      drawOp = RRectDrawOp::Make(context, std::move(provider), renderFlags);
    } break;
    case PendingOpType::Atlas: {
      bool hasColor = AnyRectHasUniqueColor(pendingRects);
      auto provider =
          RectsVertexProvider::MakeFrom(drawingBuffer(), std::move(pendingRects), aaType, hasColor,
                                        true, RectsVertexProvider::UVSubsetMode::None);
      drawOp = AtlasTextOp::Make(context, std::move(provider), renderFlags,
                                 std::move(pendingAtlasTexture));
    } break;
    default:
      break;
  }
  if (drawOp != nullptr && pendingType == PendingOpType::Image) {
    FPArgs args = {context, renderFlags, localBounds.value_or(Rect::MakeEmpty()),
                   drawScale.value_or(1.0f)};
    auto processor =
        FragmentProcessor::Make(std::move(pendingImage), args, pendingSampling, pendingConstraint);
    if (processor == nullptr) {
      return;
    }
    drawOp->addColorFP(std::move(processor));
  }
  addDrawOp(std::move(drawOp), pendingClip, pendingFill, localBounds, deviceBounds,
            drawScale.value_or(1.0f));
}

static void FlipYIfNeeded(Rect* rect, const RenderTargetProxy* renderTarget) {
  if (renderTarget->origin() == ImageOrigin::BottomLeft) {
    renderTarget->getOriginTransform().mapRect(rect);
  }
}

static bool HasColorOnly(const Fill& fill) {
  return !fill.shader && !fill.maskFilter && !fill.colorFilter;
}

bool OpsCompositor::drawAsClear(const Rect& rect, const MCState& state, const Fill& fill) {
  if (!HasColorOnly(fill) || !fill.isOpaque() || !state.matrix.rectStaysRect()) {
    return false;
  }
  auto deviceBounds = renderTarget->bounds();
  auto& clip = state.clip;
  Rect clipRect = {};
  if (clip.isInverseFillType()) {
    if (clip.isEmpty()) {
      clipRect = deviceBounds;
    } else {
      return false;
    }
  } else if (!clip.isRect(&clipRect)) {
    return false;
  }
  auto bounds = rect;
  state.matrix.mapRect(&bounds);
  if (!bounds.intersect(clipRect) || !IsPixelAligned(bounds)) {
    return false;
  }
  bounds.round();
  FlipYIfNeeded(&bounds, renderTarget.get());
  if (bounds == deviceBounds) {
    // discard all previous ops if the clear rect covers the entire render target.
    ops.clear();
  }
  auto format = renderTarget->format();
  auto caps = context->caps();
  auto& writeSwizzle = caps->getWriteSwizzle(format);
  auto color = writeSwizzle.applyTo(fill.color.premultiply());
  auto op = ClearOp::Make(context, color, bounds);
  if (op != nullptr) {
    ops.emplace_back(std::move(op));
  }
  return true;
}

void OpsCompositor::makeClosed() {
  if (renderTarget == nullptr) {
    return;
  }
  flushPendingOps();
  submitDrawOps();
  renderTarget = nullptr;
  // Remove the compositor from the list, so it won't be flushed again.
  context->drawingManager()->compositors.erase(cachedPosition);
}

AAType OpsCompositor::getAAType(const Fill& fill) const {
  if (renderTarget->sampleCount() > 1) {
    return AAType::MSAA;
  }
  if (fill.antiAlias) {
    return AAType::Coverage;
  }
  return AAType::None;
}

std::pair<bool, bool> OpsCompositor::needComputeBounds(const Fill& fill, bool hasCoverage,
                                                       bool hasImageFill) {
  bool needLocalBounds = hasImageFill || fill.shader != nullptr || fill.maskFilter != nullptr;
  bool needDeviceBounds = false;
  if (BlendModeNeedDstTexture(fill.blendMode, hasCoverage)) {
    auto caps = context->caps();
    if (!caps->frameBufferFetchSupport &&
        (!caps->textureBarrierSupport || renderTarget->asTextureProxy() == nullptr ||
         renderTarget->sampleCount() > 1)) {
      needDeviceBounds = true;
    }
  }
  return {needLocalBounds, needDeviceBounds};
}

Rect OpsCompositor::getClipBounds(const Path& clip) {
  if (clip.isInverseFillType()) {
    return renderTarget->bounds();
  }
  auto bounds = clip.getBounds();
  if (!bounds.intersect(renderTarget->bounds())) {
    bounds.setEmpty();
  }
  return bounds;
}

std::pair<std::optional<Rect>, bool> OpsCompositor::getClipRect(const Path& clip) {
  Rect rect = {};
  if (clip.isInverseFillType() || !clip.isRect(&rect)) {
    return {std::nullopt, false};
  }
  FlipYIfNeeded(&rect, renderTarget.get());
  if (IsPixelAligned(rect)) {
    rect.round();
    if (rect != renderTarget->bounds()) {
      return {rect, true};
    }
    // Cannot return '{}' as an empty Rect, since it would be interpreted as std::nullopt.
    return {Rect::MakeEmpty(), false};
  }
  return {rect, false};
}

std::shared_ptr<TextureProxy> OpsCompositor::getClipTexture(const Path& clip, AAType aaType) {
  auto uniqueKey = PathRef::GetUniqueKey(clip);
  if (aaType != AAType::None) {
    static const auto AntialiasFlag = UniqueID::Next();
    uniqueKey = UniqueKey::Append(uniqueKey, &AntialiasFlag, 1);
  }
  if (uniqueKey == clipKey) {
    return clipTexture;
  }
  auto bounds = getClipBounds(clip);
  if (bounds.isEmpty()) {
    return nullptr;
  }
  auto width = static_cast<int>(ceilf(bounds.width()));
  auto height = static_cast<int>(ceilf(bounds.height()));
  auto rasterizeMatrix = Matrix::MakeTrans(-bounds.left, -bounds.top);
  if (PathTriangulator::ShouldTriangulatePath(clip)) {
    auto clipBounds = Rect::MakeWH(width, height);
    auto shape = Shape::MakeFrom(clip);
    shape = Shape::ApplyMatrix(std::move(shape), rasterizeMatrix);
    auto shapeProxy = proxyProvider()->createGPUShapeProxy(shape, aaType, clipBounds, renderFlags);
    auto uvMatrix = Matrix::MakeTrans(bounds.left, bounds.top);
    auto drawOp = ShapeDrawOp::Make(std::move(shapeProxy), {}, uvMatrix, aaType);
    auto clipRenderTarget = RenderTargetProxy::MakeFallback(
        context, width, height, true, 1, false, ImageOrigin::TopLeft, BackingFit::Approx);
    if (clipRenderTarget == nullptr) {
      return nullptr;
    }
    clipTexture = clipRenderTarget->asTextureProxy();
    auto clearOp = ClearOp::Make(context, Color::Transparent(), clipRenderTarget->bounds());
    auto opList = drawingBuffer()->makeArray<Op>(2);
    opList[0] = std::move(clearOp);
    opList[1] = std::move(drawOp);
    context->drawingManager()->addOpsRenderTask(std::move(clipRenderTarget), std::move(opList));
  } else {
    auto rasterizer =
        PathRasterizer::MakeFrom(width, height, clip, aaType != AAType::None, &rasterizeMatrix);
    clipTexture = proxyProvider()->createTextureProxy(rasterizer, false, renderFlags);
  }
  clipKey = uniqueKey;
  return clipTexture;
}

std::pair<PlacementPtr<FragmentProcessor>, bool> OpsCompositor::getClipMaskFP(const Path& clip,
                                                                              AAType aaType,
                                                                              Rect* scissorRect) {
  if (clip.isEmpty() && clip.isInverseFillType()) {
    return {nullptr, false};
  }
  auto buffer = context->drawingBuffer();
  auto [rect, useScissor] = getClipRect(clip);
  if (rect.has_value()) {
    if (!rect->isEmpty()) {
      *scissorRect = *rect;
      if (!useScissor) {
        scissorRect->roundOut();
        return {AARectEffect::Make(buffer, *rect), true};
      }
    }
    return {nullptr, false};
  }
  auto clipBounds = getClipBounds(clip);
  *scissorRect = clipBounds;
  FlipYIfNeeded(scissorRect, renderTarget.get());
  scissorRect->roundOut();
  auto textureProxy = getClipTexture(clip, aaType);
  auto uvMatrix = Matrix::MakeTrans(-clipBounds.left, -clipBounds.top);
  if (renderTarget->origin() == ImageOrigin::BottomLeft) {
    uvMatrix.preConcat(renderTarget->getOriginTransform());
  }
  auto processor = DeviceSpaceTextureEffect::Make(buffer, std::move(textureProxy), uvMatrix);
  return {FragmentProcessor::MulInputByChildAlpha(buffer, std::move(processor)), true};
}

DstTextureInfo OpsCompositor::makeDstTextureInfo(const Rect& deviceBounds, AAType aaType) {
  auto caps = context->caps();
  if (caps->frameBufferFetchSupport) {
    return {};
  }
  Rect bounds = {};
  auto textureProxy = caps->textureBarrierSupport ? renderTarget->asTextureProxy() : nullptr;
  if (textureProxy == nullptr || renderTarget->sampleCount() > 1) {
    if (deviceBounds.isEmpty()) {
      return {};
    }
    bounds = deviceBounds;
    if (aaType != AAType::None) {
      bounds.outset(1.0f, 1.0f);
    }
    bounds.roundOut();
    if (!bounds.intersect(renderTarget->bounds())) {
      return {};
    }
    FlipYIfNeeded(&bounds, renderTarget.get());
  }
  DstTextureInfo dstTextureInfo = {};
  if (textureProxy != nullptr) {
    if (renderTarget->sampleCount() > 1) {
      // Submit draw ops immediately to ensure the MSAA render target is resolved.
      submitDrawOps();
    }
    dstTextureInfo.textureProxy = std::move(textureProxy);
    dstTextureInfo.requiresBarrier = true;
    return dstTextureInfo;
  }
  submitDrawOps();
  dstTextureInfo.offset = {bounds.x(), bounds.y()};
  textureProxy = proxyProvider()->createTextureProxy(
      {}, static_cast<int>(bounds.width()), static_cast<int>(bounds.height()),
      renderTarget->format(), false, renderTarget->origin(), BackingFit::Approx);
  if (textureProxy == nullptr) {
    return {};
  }
  context->drawingManager()->addRenderTargetCopyTask(
      renderTarget, textureProxy, static_cast<int>(bounds.x()), static_cast<int>(bounds.y()));
  dstTextureInfo.textureProxy = std::move(textureProxy);
  return dstTextureInfo;
}

void OpsCompositor::addDrawOp(PlacementPtr<DrawOp> op, const Path& clip, const Fill& fill,
                              const std::optional<Rect>& localBounds,
                              const std::optional<Rect>& deviceBounds, float drawScale) {

  if (op == nullptr || fill.nothingToDraw() || (clip.isEmpty() && !clip.isInverseFillType())) {
    return;
  }
  DEBUG_ASSERT(renderTarget != nullptr);
  if (localBounds.has_value() && localBounds->isEmpty()) {
    return;
  }

  FPArgs args = {context, renderFlags, localBounds.value_or(Rect::MakeEmpty()), drawScale};
  if (fill.shader) {
    if (auto processor = FragmentProcessor::Make(fill.shader, args)) {
      op->addColorFP(std::move(processor));
    } else {
      // The shader is the main source of color, so if it fails to create a processor, we can't
      // draw anything.
      return;
    }
  }
  if (fill.colorFilter) {
    if (auto processor = fill.colorFilter->asFragmentProcessor(context)) {
      op->addColorFP(std::move(processor));
    }
  }
  if (fill.maskFilter) {
    if (auto processor = fill.maskFilter->asFragmentProcessor(args, nullptr)) {
      op->addCoverageFP(std::move(processor));
    } else {
      // if mask is empty, nothing to draw
      return;
    }
  }
  Rect scissorRect = {};
  auto aaType = getAAType(fill);
  auto [clipMask, hasMask] = getClipMaskFP(clip, aaType, &scissorRect);
  if (hasMask) {
    if (!clipMask) {
      return;
    }
    op->addCoverageFP(std::move(clipMask));
  }
  op->setScissorRect(scissorRect);
  op->setBlendMode(fill.blendMode);
  if (BlendModeNeedDstTexture(fill.blendMode, op->hasCoverage())) {
    auto dstTextureInfo = makeDstTextureInfo(deviceBounds.value_or(Rect::MakeEmpty()), aaType);
    if (!context->caps()->frameBufferFetchSupport && dstTextureInfo.textureProxy == nullptr) {
      return;
    }
    auto xferProcessor =
        PorterDuffXferProcessor::Make(drawingBuffer(), fill.blendMode, std::move(dstTextureInfo));
    op->setXferProcessor(std::move(xferProcessor));
  }
  ops.emplace_back(std::move(op));
}

void OpsCompositor::fillTextAtlas(std::shared_ptr<TextureProxy> textureProxy, const Rect& rect,
                                  const MCState& state, const Fill& fill) {
  DEBUG_ASSERT(textureProxy != nullptr);
  DEBUG_ASSERT(!rect.isEmpty());
  if (!canAppend(PendingOpType::Atlas, state.clip, fill) || pendingAtlasTexture != textureProxy) {
    flushPendingOps(PendingOpType::Atlas, state.clip, fill);
    pendingAtlasTexture = std::move(textureProxy);
  }
  auto record = drawingBuffer()->make<RectRecord>(rect, state.matrix, fill.color.premultiply());
  pendingRects.emplace_back(std::move(record));
}

void OpsCompositor::submitDrawOps() {
  auto opArray = drawingBuffer()->makeArray(std::move(ops));
  context->drawingManager()->addOpsRenderTask(renderTarget, std::move(opArray));
}

}  // namespace tgfx
