// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SERIALIZATIONSTRUCTURE_TGFX_FBS_H_
#define FLATBUFFERS_GENERATED_SERIALIZATIONSTRUCTURE_TGFX_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace tgfx {
namespace fbs {

struct LayerStyleCommonAttribute;

struct BackGroundBlurStyleAttribute;
struct BackGroundBlurStyleAttributeBuilder;

struct Color;

struct DropShadowStyleAttribute;
struct DropShadowStyleAttributeBuilder;

struct InnerShadowStyleAttribute;
struct InnerShadowStyleAttributeBuilder;

struct LayerfilterCommonAttribute;

struct BlendFilterAttribute;
struct BlendFilterAttributeBuilder;

struct BlurFilterAttribute;
struct BlurFilterAttributeBuilder;

struct Matrix;

struct ColorFilterAttribute;
struct ColorFilterAttributeBuilder;

struct DropShadowFilterAttribute;
struct DropShadowFilterAttributeBuilder;

struct InnerShadowFilterAttribute;
struct InnerShadowFilterAttributeBuilder;

struct Point;

struct LayerStyle;
struct LayerStyleBuilder;

struct LayerFilter;
struct LayerFilterBuilder;

struct LayerCommonAttribute;
struct LayerCommonAttributeBuilder;

struct ImageAttribute;

struct ImageLayerAttribute;
struct ImageLayerAttributeBuilder;

struct ShapeStyleCommonAttribute;

struct ImagePatternAttribute;
struct ImagePatternAttributeBuilder;

struct GradientAttribute;
struct GradientAttributeBuilder;

struct LinearGradientAttribute;
struct LinearGradientAttributeBuilder;

struct RadialGradientAttribute;
struct RadialGradientAttributeBuilder;

struct ConicGradientAttribute;
struct ConicGradientAttributeBuilder;

struct DiamondGradientAttribute;
struct DiamondGradientAttributeBuilder;

struct ShapeStyle;
struct ShapeStyleBuilder;

struct Rect;

struct ShapeLayerAttribute;
struct ShapeLayerAttributeBuilder;

struct SolidLayerAttribute;
struct SolidLayerAttributeBuilder;

struct TypeFace;
struct TypeFaceBuilder;

struct FontMetrics;

struct Font;
struct FontBuilder;

struct TextLayerAttribute;
struct TextLayerAttributeBuilder;

struct Layer;
struct LayerBuilder;

struct TreeNode;
struct TreeNodeBuilder;

struct FinalData;
struct FinalDataBuilder;

enum LayerStyleType : int8_t {
  LayerStyleType_BackgroundBlur = 0,
  LayerStyleType_DropShadow = 1,
  LayerStyleType_InnerShadow = 2,
  LayerStyleType_MIN = LayerStyleType_BackgroundBlur,
  LayerStyleType_MAX = LayerStyleType_InnerShadow
};

inline const LayerStyleType (&EnumValuesLayerStyleType())[3] {
  static const LayerStyleType values[] = {
    LayerStyleType_BackgroundBlur,
    LayerStyleType_DropShadow,
    LayerStyleType_InnerShadow
  };
  return values;
}

inline const char * const *EnumNamesLayerStyleType() {
  static const char * const names[4] = {
    "BackgroundBlur",
    "DropShadow",
    "InnerShadow",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayerStyleType(LayerStyleType e) {
  if (::flatbuffers::IsOutRange(e, LayerStyleType_BackgroundBlur, LayerStyleType_InnerShadow)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayerStyleType()[index];
}

enum BlendMode : int8_t {
  BlendMode_Clear = 0,
  BlendMode_Src = 1,
  BlendMode_Dst = 2,
  BlendMode_SrcOver = 3,
  BlendMode_DstOver = 4,
  BlendMode_SrcIn = 5,
  BlendMode_DstIn = 6,
  BlendMode_SrcOut = 7,
  BlendMode_DstOut = 8,
  BlendMode_SrcATop = 9,
  BlendMode_DstATop = 10,
  BlendMode_Xor = 11,
  BlendMode_PlusLighter = 12,
  BlendMode_Modulate = 13,
  BlendMode_Screen = 14,
  BlendMode_Overlay = 15,
  BlendMode_Darken = 16,
  BlendMode_Lighten = 17,
  BlendMode_ColorDodge = 18,
  BlendMode_ColorBurn = 19,
  BlendMode_HardLight = 20,
  BlendMode_SoftLight = 21,
  BlendMode_Difference = 22,
  BlendMode_Exclusion = 23,
  BlendMode_Multiply = 24,
  BlendMode_Hue = 25,
  BlendMode_Saturation = 26,
  BlendMode_Color = 27,
  BlendMode_Luminosity = 28,
  BlendMode_PlusDarker = 29,
  BlendMode_MIN = BlendMode_Clear,
  BlendMode_MAX = BlendMode_PlusDarker
};

inline const BlendMode (&EnumValuesBlendMode())[30] {
  static const BlendMode values[] = {
    BlendMode_Clear,
    BlendMode_Src,
    BlendMode_Dst,
    BlendMode_SrcOver,
    BlendMode_DstOver,
    BlendMode_SrcIn,
    BlendMode_DstIn,
    BlendMode_SrcOut,
    BlendMode_DstOut,
    BlendMode_SrcATop,
    BlendMode_DstATop,
    BlendMode_Xor,
    BlendMode_PlusLighter,
    BlendMode_Modulate,
    BlendMode_Screen,
    BlendMode_Overlay,
    BlendMode_Darken,
    BlendMode_Lighten,
    BlendMode_ColorDodge,
    BlendMode_ColorBurn,
    BlendMode_HardLight,
    BlendMode_SoftLight,
    BlendMode_Difference,
    BlendMode_Exclusion,
    BlendMode_Multiply,
    BlendMode_Hue,
    BlendMode_Saturation,
    BlendMode_Color,
    BlendMode_Luminosity,
    BlendMode_PlusDarker
  };
  return values;
}

inline const char * const *EnumNamesBlendMode() {
  static const char * const names[31] = {
    "Clear",
    "Src",
    "Dst",
    "SrcOver",
    "DstOver",
    "SrcIn",
    "DstIn",
    "SrcOut",
    "DstOut",
    "SrcATop",
    "DstATop",
    "Xor",
    "PlusLighter",
    "Modulate",
    "Screen",
    "Overlay",
    "Darken",
    "Lighten",
    "ColorDodge",
    "ColorBurn",
    "HardLight",
    "SoftLight",
    "Difference",
    "Exclusion",
    "Multiply",
    "Hue",
    "Saturation",
    "Color",
    "Luminosity",
    "PlusDarker",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlendMode(BlendMode e) {
  if (::flatbuffers::IsOutRange(e, BlendMode_Clear, BlendMode_PlusDarker)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBlendMode()[index];
}

enum LayerStylePosition : int8_t {
  LayerStylePosition_Above = 0,
  LayerStylePosition_Below = 1,
  LayerStylePosition_MIN = LayerStylePosition_Above,
  LayerStylePosition_MAX = LayerStylePosition_Below
};

inline const LayerStylePosition (&EnumValuesLayerStylePosition())[2] {
  static const LayerStylePosition values[] = {
    LayerStylePosition_Above,
    LayerStylePosition_Below
  };
  return values;
}

inline const char * const *EnumNamesLayerStylePosition() {
  static const char * const names[3] = {
    "Above",
    "Below",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayerStylePosition(LayerStylePosition e) {
  if (::flatbuffers::IsOutRange(e, LayerStylePosition_Above, LayerStylePosition_Below)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayerStylePosition()[index];
}

enum LayerStyleExtraSourceType : int8_t {
  LayerStyleExtraSourceType_None = 0,
  LayerStyleExtraSourceType_Contour = 1,
  LayerStyleExtraSourceType_Background = 2,
  LayerStyleExtraSourceType_MIN = LayerStyleExtraSourceType_None,
  LayerStyleExtraSourceType_MAX = LayerStyleExtraSourceType_Background
};

inline const LayerStyleExtraSourceType (&EnumValuesLayerStyleExtraSourceType())[3] {
  static const LayerStyleExtraSourceType values[] = {
    LayerStyleExtraSourceType_None,
    LayerStyleExtraSourceType_Contour,
    LayerStyleExtraSourceType_Background
  };
  return values;
}

inline const char * const *EnumNamesLayerStyleExtraSourceType() {
  static const char * const names[4] = {
    "None",
    "Contour",
    "Background",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayerStyleExtraSourceType(LayerStyleExtraSourceType e) {
  if (::flatbuffers::IsOutRange(e, LayerStyleExtraSourceType_None, LayerStyleExtraSourceType_Background)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayerStyleExtraSourceType()[index];
}

enum TileMode : int8_t {
  TileMode_Clamp = 0,
  TileMode_Repeat = 1,
  TileMode_Mirror = 2,
  TileMode_Decal = 3,
  TileMode_MIN = TileMode_Clamp,
  TileMode_MAX = TileMode_Decal
};

inline const TileMode (&EnumValuesTileMode())[4] {
  static const TileMode values[] = {
    TileMode_Clamp,
    TileMode_Repeat,
    TileMode_Mirror,
    TileMode_Decal
  };
  return values;
}

inline const char * const *EnumNamesTileMode() {
  static const char * const names[5] = {
    "Clamp",
    "Repeat",
    "Mirror",
    "Decal",
    nullptr
  };
  return names;
}

inline const char *EnumNameTileMode(TileMode e) {
  if (::flatbuffers::IsOutRange(e, TileMode_Clamp, TileMode_Decal)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTileMode()[index];
}

enum LayerFilterType : int8_t {
  LayerFilterType_LayerFilter = 0,
  LayerFilterType_BlendFilter = 1,
  LayerFilterType_BlurFilter = 2,
  LayerFilterType_ColorMatrixFliter = 3,
  LayerFilterType_DropShadowFilter = 4,
  LayerFilterType_InnerShadowFilter = 5,
  LayerFilterType_MIN = LayerFilterType_LayerFilter,
  LayerFilterType_MAX = LayerFilterType_InnerShadowFilter
};

inline const LayerFilterType (&EnumValuesLayerFilterType())[6] {
  static const LayerFilterType values[] = {
    LayerFilterType_LayerFilter,
    LayerFilterType_BlendFilter,
    LayerFilterType_BlurFilter,
    LayerFilterType_ColorMatrixFliter,
    LayerFilterType_DropShadowFilter,
    LayerFilterType_InnerShadowFilter
  };
  return values;
}

inline const char * const *EnumNamesLayerFilterType() {
  static const char * const names[7] = {
    "LayerFilter",
    "BlendFilter",
    "BlurFilter",
    "ColorMatrixFliter",
    "DropShadowFilter",
    "InnerShadowFilter",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayerFilterType(LayerFilterType e) {
  if (::flatbuffers::IsOutRange(e, LayerFilterType_LayerFilter, LayerFilterType_InnerShadowFilter)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayerFilterType()[index];
}

enum LayerType : int8_t {
  LayerType_Layer = 0,
  LayerType_Image = 1,
  LayerType_Shape = 2,
  LayerType_Gradient = 3,
  LayerType_Text = 4,
  LayerType_Solid = 5,
  LayerType_MIN = LayerType_Layer,
  LayerType_MAX = LayerType_Solid
};

inline const LayerType (&EnumValuesLayerType())[6] {
  static const LayerType values[] = {
    LayerType_Layer,
    LayerType_Image,
    LayerType_Shape,
    LayerType_Gradient,
    LayerType_Text,
    LayerType_Solid
  };
  return values;
}

inline const char * const *EnumNamesLayerType() {
  static const char * const names[7] = {
    "Layer",
    "Image",
    "Shape",
    "Gradient",
    "Text",
    "Solid",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayerType(LayerType e) {
  if (::flatbuffers::IsOutRange(e, LayerType_Layer, LayerType_Solid)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayerType()[index];
}

enum LayerStyleAttribute : uint8_t {
  LayerStyleAttribute_NONE = 0,
  LayerStyleAttribute_BackGroundBlurStyleAttribute = 1,
  LayerStyleAttribute_DropShadowStyleAttribute = 2,
  LayerStyleAttribute_InnerShadowStyleAttribute = 3,
  LayerStyleAttribute_MIN = LayerStyleAttribute_NONE,
  LayerStyleAttribute_MAX = LayerStyleAttribute_InnerShadowStyleAttribute
};

inline const LayerStyleAttribute (&EnumValuesLayerStyleAttribute())[4] {
  static const LayerStyleAttribute values[] = {
    LayerStyleAttribute_NONE,
    LayerStyleAttribute_BackGroundBlurStyleAttribute,
    LayerStyleAttribute_DropShadowStyleAttribute,
    LayerStyleAttribute_InnerShadowStyleAttribute
  };
  return values;
}

inline const char * const *EnumNamesLayerStyleAttribute() {
  static const char * const names[5] = {
    "NONE",
    "BackGroundBlurStyleAttribute",
    "DropShadowStyleAttribute",
    "InnerShadowStyleAttribute",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayerStyleAttribute(LayerStyleAttribute e) {
  if (::flatbuffers::IsOutRange(e, LayerStyleAttribute_NONE, LayerStyleAttribute_InnerShadowStyleAttribute)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayerStyleAttribute()[index];
}

template<typename T> struct LayerStyleAttributeTraits {
  static const LayerStyleAttribute enum_value = LayerStyleAttribute_NONE;
};

template<> struct LayerStyleAttributeTraits<tgfx::fbs::BackGroundBlurStyleAttribute> {
  static const LayerStyleAttribute enum_value = LayerStyleAttribute_BackGroundBlurStyleAttribute;
};

template<> struct LayerStyleAttributeTraits<tgfx::fbs::DropShadowStyleAttribute> {
  static const LayerStyleAttribute enum_value = LayerStyleAttribute_DropShadowStyleAttribute;
};

template<> struct LayerStyleAttributeTraits<tgfx::fbs::InnerShadowStyleAttribute> {
  static const LayerStyleAttribute enum_value = LayerStyleAttribute_InnerShadowStyleAttribute;
};

bool VerifyLayerStyleAttribute(::flatbuffers::Verifier &verifier, const void *obj, LayerStyleAttribute type);
bool VerifyLayerStyleAttributeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum LayerFilterAttribute : uint8_t {
  LayerFilterAttribute_NONE = 0,
  LayerFilterAttribute_BlendFilterAttribute = 1,
  LayerFilterAttribute_BlurFilterAttribute = 2,
  LayerFilterAttribute_ColorFilterAttribute = 3,
  LayerFilterAttribute_DropShadowFilterAttribute = 4,
  LayerFilterAttribute_InnerShadowFilterAttribute = 5,
  LayerFilterAttribute_MIN = LayerFilterAttribute_NONE,
  LayerFilterAttribute_MAX = LayerFilterAttribute_InnerShadowFilterAttribute
};

inline const LayerFilterAttribute (&EnumValuesLayerFilterAttribute())[6] {
  static const LayerFilterAttribute values[] = {
    LayerFilterAttribute_NONE,
    LayerFilterAttribute_BlendFilterAttribute,
    LayerFilterAttribute_BlurFilterAttribute,
    LayerFilterAttribute_ColorFilterAttribute,
    LayerFilterAttribute_DropShadowFilterAttribute,
    LayerFilterAttribute_InnerShadowFilterAttribute
  };
  return values;
}

inline const char * const *EnumNamesLayerFilterAttribute() {
  static const char * const names[7] = {
    "NONE",
    "BlendFilterAttribute",
    "BlurFilterAttribute",
    "ColorFilterAttribute",
    "DropShadowFilterAttribute",
    "InnerShadowFilterAttribute",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayerFilterAttribute(LayerFilterAttribute e) {
  if (::flatbuffers::IsOutRange(e, LayerFilterAttribute_NONE, LayerFilterAttribute_InnerShadowFilterAttribute)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayerFilterAttribute()[index];
}

template<typename T> struct LayerFilterAttributeTraits {
  static const LayerFilterAttribute enum_value = LayerFilterAttribute_NONE;
};

template<> struct LayerFilterAttributeTraits<tgfx::fbs::BlendFilterAttribute> {
  static const LayerFilterAttribute enum_value = LayerFilterAttribute_BlendFilterAttribute;
};

template<> struct LayerFilterAttributeTraits<tgfx::fbs::BlurFilterAttribute> {
  static const LayerFilterAttribute enum_value = LayerFilterAttribute_BlurFilterAttribute;
};

template<> struct LayerFilterAttributeTraits<tgfx::fbs::ColorFilterAttribute> {
  static const LayerFilterAttribute enum_value = LayerFilterAttribute_ColorFilterAttribute;
};

template<> struct LayerFilterAttributeTraits<tgfx::fbs::DropShadowFilterAttribute> {
  static const LayerFilterAttribute enum_value = LayerFilterAttribute_DropShadowFilterAttribute;
};

template<> struct LayerFilterAttributeTraits<tgfx::fbs::InnerShadowFilterAttribute> {
  static const LayerFilterAttribute enum_value = LayerFilterAttribute_InnerShadowFilterAttribute;
};

bool VerifyLayerFilterAttribute(::flatbuffers::Verifier &verifier, const void *obj, LayerFilterAttribute type);
bool VerifyLayerFilterAttributeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum FilterMode : int8_t {
  FilterMode_Nearest = 0,
  FilterMode_Linear = 1,
  FilterMode_MIN = FilterMode_Nearest,
  FilterMode_MAX = FilterMode_Linear
};

inline const FilterMode (&EnumValuesFilterMode())[2] {
  static const FilterMode values[] = {
    FilterMode_Nearest,
    FilterMode_Linear
  };
  return values;
}

inline const char * const *EnumNamesFilterMode() {
  static const char * const names[3] = {
    "Nearest",
    "Linear",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilterMode(FilterMode e) {
  if (::flatbuffers::IsOutRange(e, FilterMode_Nearest, FilterMode_Linear)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFilterMode()[index];
}

enum MipmapMode : int8_t {
  MipmapMode_None = 0,
  MipmapMode_Nearest = 1,
  MipmapMode_Linear = 2,
  MipmapMode_MIN = MipmapMode_None,
  MipmapMode_MAX = MipmapMode_Linear
};

inline const MipmapMode (&EnumValuesMipmapMode())[3] {
  static const MipmapMode values[] = {
    MipmapMode_None,
    MipmapMode_Nearest,
    MipmapMode_Linear
  };
  return values;
}

inline const char * const *EnumNamesMipmapMode() {
  static const char * const names[4] = {
    "None",
    "Nearest",
    "Linear",
    nullptr
  };
  return names;
}

inline const char *EnumNameMipmapMode(MipmapMode e) {
  if (::flatbuffers::IsOutRange(e, MipmapMode_None, MipmapMode_Linear)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMipmapMode()[index];
}

enum GradientType : int8_t {
  GradientType_None = 0,
  GradientType_Linear = 1,
  GradientType_Radial = 2,
  GradientType_Conic = 3,
  GradientType_Diamond = 4,
  GradientType_MIN = GradientType_None,
  GradientType_MAX = GradientType_Diamond
};

inline const GradientType (&EnumValuesGradientType())[5] {
  static const GradientType values[] = {
    GradientType_None,
    GradientType_Linear,
    GradientType_Radial,
    GradientType_Conic,
    GradientType_Diamond
  };
  return values;
}

inline const char * const *EnumNamesGradientType() {
  static const char * const names[6] = {
    "None",
    "Linear",
    "Radial",
    "Conic",
    "Diamond",
    nullptr
  };
  return names;
}

inline const char *EnumNameGradientType(GradientType e) {
  if (::flatbuffers::IsOutRange(e, GradientType_None, GradientType_Diamond)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGradientType()[index];
}

enum ShapeStyleType : int8_t {
  ShapeStyleType_LinearGradient = 0,
  ShapeStyleType_RadiusGradient = 1,
  ShapeStyleType_ConicGradient = 2,
  ShapeStyleType_DiamondGradient = 3,
  ShapeStyleType_ImagePattern = 4,
  ShapeStyleType_MIN = ShapeStyleType_LinearGradient,
  ShapeStyleType_MAX = ShapeStyleType_ImagePattern
};

inline const ShapeStyleType (&EnumValuesShapeStyleType())[5] {
  static const ShapeStyleType values[] = {
    ShapeStyleType_LinearGradient,
    ShapeStyleType_RadiusGradient,
    ShapeStyleType_ConicGradient,
    ShapeStyleType_DiamondGradient,
    ShapeStyleType_ImagePattern
  };
  return values;
}

inline const char * const *EnumNamesShapeStyleType() {
  static const char * const names[6] = {
    "LinearGradient",
    "RadiusGradient",
    "ConicGradient",
    "DiamondGradient",
    "ImagePattern",
    nullptr
  };
  return names;
}

inline const char *EnumNameShapeStyleType(ShapeStyleType e) {
  if (::flatbuffers::IsOutRange(e, ShapeStyleType_LinearGradient, ShapeStyleType_ImagePattern)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesShapeStyleType()[index];
}

enum ShapeStyleAttribute : uint8_t {
  ShapeStyleAttribute_NONE = 0,
  ShapeStyleAttribute_LinearGradientAttribute = 1,
  ShapeStyleAttribute_RadialGradientAttribute = 2,
  ShapeStyleAttribute_ConicGradientAttribute = 3,
  ShapeStyleAttribute_DiamondGradientAttribute = 4,
  ShapeStyleAttribute_ImagePatternAttribute = 5,
  ShapeStyleAttribute_MIN = ShapeStyleAttribute_NONE,
  ShapeStyleAttribute_MAX = ShapeStyleAttribute_ImagePatternAttribute
};

inline const ShapeStyleAttribute (&EnumValuesShapeStyleAttribute())[6] {
  static const ShapeStyleAttribute values[] = {
    ShapeStyleAttribute_NONE,
    ShapeStyleAttribute_LinearGradientAttribute,
    ShapeStyleAttribute_RadialGradientAttribute,
    ShapeStyleAttribute_ConicGradientAttribute,
    ShapeStyleAttribute_DiamondGradientAttribute,
    ShapeStyleAttribute_ImagePatternAttribute
  };
  return values;
}

inline const char * const *EnumNamesShapeStyleAttribute() {
  static const char * const names[7] = {
    "NONE",
    "LinearGradientAttribute",
    "RadialGradientAttribute",
    "ConicGradientAttribute",
    "DiamondGradientAttribute",
    "ImagePatternAttribute",
    nullptr
  };
  return names;
}

inline const char *EnumNameShapeStyleAttribute(ShapeStyleAttribute e) {
  if (::flatbuffers::IsOutRange(e, ShapeStyleAttribute_NONE, ShapeStyleAttribute_ImagePatternAttribute)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesShapeStyleAttribute()[index];
}

template<typename T> struct ShapeStyleAttributeTraits {
  static const ShapeStyleAttribute enum_value = ShapeStyleAttribute_NONE;
};

template<> struct ShapeStyleAttributeTraits<tgfx::fbs::LinearGradientAttribute> {
  static const ShapeStyleAttribute enum_value = ShapeStyleAttribute_LinearGradientAttribute;
};

template<> struct ShapeStyleAttributeTraits<tgfx::fbs::RadialGradientAttribute> {
  static const ShapeStyleAttribute enum_value = ShapeStyleAttribute_RadialGradientAttribute;
};

template<> struct ShapeStyleAttributeTraits<tgfx::fbs::ConicGradientAttribute> {
  static const ShapeStyleAttribute enum_value = ShapeStyleAttribute_ConicGradientAttribute;
};

template<> struct ShapeStyleAttributeTraits<tgfx::fbs::DiamondGradientAttribute> {
  static const ShapeStyleAttribute enum_value = ShapeStyleAttribute_DiamondGradientAttribute;
};

template<> struct ShapeStyleAttributeTraits<tgfx::fbs::ImagePatternAttribute> {
  static const ShapeStyleAttribute enum_value = ShapeStyleAttribute_ImagePatternAttribute;
};

bool VerifyShapeStyleAttribute(::flatbuffers::Verifier &verifier, const void *obj, ShapeStyleAttribute type);
bool VerifyShapeStyleAttributeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum PathFillType : int8_t {
  PathFillType_Winding = 0,
  PathFillType_EvenOdd = 1,
  PathFillType_InverseWinding = 2,
  PathFillType_InverseEvenOdd = 3,
  PathFillType_MIN = PathFillType_Winding,
  PathFillType_MAX = PathFillType_InverseEvenOdd
};

inline const PathFillType (&EnumValuesPathFillType())[4] {
  static const PathFillType values[] = {
    PathFillType_Winding,
    PathFillType_EvenOdd,
    PathFillType_InverseWinding,
    PathFillType_InverseEvenOdd
  };
  return values;
}

inline const char * const *EnumNamesPathFillType() {
  static const char * const names[5] = {
    "Winding",
    "EvenOdd",
    "InverseWinding",
    "InverseEvenOdd",
    nullptr
  };
  return names;
}

inline const char *EnumNamePathFillType(PathFillType e) {
  if (::flatbuffers::IsOutRange(e, PathFillType_Winding, PathFillType_InverseEvenOdd)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPathFillType()[index];
}

enum TextAlign : int8_t {
  TextAlign_Left = 0,
  TextAlign_Right = 1,
  TextAlign_Center = 2,
  TextAlign_Justify = 3,
  TextAlign_MIN = TextAlign_Left,
  TextAlign_MAX = TextAlign_Justify
};

inline const TextAlign (&EnumValuesTextAlign())[4] {
  static const TextAlign values[] = {
    TextAlign_Left,
    TextAlign_Right,
    TextAlign_Center,
    TextAlign_Justify
  };
  return values;
}

inline const char * const *EnumNamesTextAlign() {
  static const char * const names[5] = {
    "Left",
    "Right",
    "Center",
    "Justify",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextAlign(TextAlign e) {
  if (::flatbuffers::IsOutRange(e, TextAlign_Left, TextAlign_Justify)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextAlign()[index];
}

enum LayerAttribute : uint8_t {
  LayerAttribute_NONE = 0,
  LayerAttribute_LayerCommonAttribute = 1,
  LayerAttribute_ImageLayerAttribute = 2,
  LayerAttribute_ShapeLayerAttribute = 3,
  LayerAttribute_SolidLayerAttribute = 4,
  LayerAttribute_TextLayerAttribute = 5,
  LayerAttribute_MIN = LayerAttribute_NONE,
  LayerAttribute_MAX = LayerAttribute_TextLayerAttribute
};

inline const LayerAttribute (&EnumValuesLayerAttribute())[6] {
  static const LayerAttribute values[] = {
    LayerAttribute_NONE,
    LayerAttribute_LayerCommonAttribute,
    LayerAttribute_ImageLayerAttribute,
    LayerAttribute_ShapeLayerAttribute,
    LayerAttribute_SolidLayerAttribute,
    LayerAttribute_TextLayerAttribute
  };
  return values;
}

inline const char * const *EnumNamesLayerAttribute() {
  static const char * const names[7] = {
    "NONE",
    "LayerCommonAttribute",
    "ImageLayerAttribute",
    "ShapeLayerAttribute",
    "SolidLayerAttribute",
    "TextLayerAttribute",
    nullptr
  };
  return names;
}

inline const char *EnumNameLayerAttribute(LayerAttribute e) {
  if (::flatbuffers::IsOutRange(e, LayerAttribute_NONE, LayerAttribute_TextLayerAttribute)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLayerAttribute()[index];
}

template<typename T> struct LayerAttributeTraits {
  static const LayerAttribute enum_value = LayerAttribute_NONE;
};

template<> struct LayerAttributeTraits<tgfx::fbs::LayerCommonAttribute> {
  static const LayerAttribute enum_value = LayerAttribute_LayerCommonAttribute;
};

template<> struct LayerAttributeTraits<tgfx::fbs::ImageLayerAttribute> {
  static const LayerAttribute enum_value = LayerAttribute_ImageLayerAttribute;
};

template<> struct LayerAttributeTraits<tgfx::fbs::ShapeLayerAttribute> {
  static const LayerAttribute enum_value = LayerAttribute_ShapeLayerAttribute;
};

template<> struct LayerAttributeTraits<tgfx::fbs::SolidLayerAttribute> {
  static const LayerAttribute enum_value = LayerAttribute_SolidLayerAttribute;
};

template<> struct LayerAttributeTraits<tgfx::fbs::TextLayerAttribute> {
  static const LayerAttribute enum_value = LayerAttribute_TextLayerAttribute;
};

bool VerifyLayerAttribute(::flatbuffers::Verifier &verifier, const void *obj, LayerAttribute type);
bool VerifyLayerAttributeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Type : int8_t {
  Type_TreeData = 0,
  Type_LayerData = 1,
  Type_MIN = Type_TreeData,
  Type_MAX = Type_LayerData
};

inline const Type (&EnumValuesType())[2] {
  static const Type values[] = {
    Type_TreeData,
    Type_LayerData
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[3] = {
    "TreeData",
    "LayerData",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (::flatbuffers::IsOutRange(e, Type_TreeData, Type_LayerData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

enum Data : uint8_t {
  Data_NONE = 0,
  Data_Layer = 1,
  Data_TreeNode = 2,
  Data_MIN = Data_NONE,
  Data_MAX = Data_TreeNode
};

inline const Data (&EnumValuesData())[3] {
  static const Data values[] = {
    Data_NONE,
    Data_Layer,
    Data_TreeNode
  };
  return values;
}

inline const char * const *EnumNamesData() {
  static const char * const names[4] = {
    "NONE",
    "Layer",
    "TreeNode",
    nullptr
  };
  return names;
}

inline const char *EnumNameData(Data e) {
  if (::flatbuffers::IsOutRange(e, Data_NONE, Data_TreeNode)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesData()[index];
}

template<typename T> struct DataTraits {
  static const Data enum_value = Data_NONE;
};

template<> struct DataTraits<tgfx::fbs::Layer> {
  static const Data enum_value = Data_Layer;
};

template<> struct DataTraits<tgfx::fbs::TreeNode> {
  static const Data enum_value = Data_TreeNode;
};

bool VerifyData(::flatbuffers::Verifier &verifier, const void *obj, Data type);
bool VerifyDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) LayerStyleCommonAttribute FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t type_;
  int8_t blend_mode_;
  int8_t position_;
  int8_t source_type_;

 public:
  LayerStyleCommonAttribute()
      : type_(0),
        blend_mode_(0),
        position_(0),
        source_type_(0) {
  }
  LayerStyleCommonAttribute(tgfx::fbs::LayerStyleType _type, tgfx::fbs::BlendMode _blend_mode, tgfx::fbs::LayerStylePosition _position, tgfx::fbs::LayerStyleExtraSourceType _source_type)
      : type_(::flatbuffers::EndianScalar(static_cast<int8_t>(_type))),
        blend_mode_(::flatbuffers::EndianScalar(static_cast<int8_t>(_blend_mode))),
        position_(::flatbuffers::EndianScalar(static_cast<int8_t>(_position))),
        source_type_(::flatbuffers::EndianScalar(static_cast<int8_t>(_source_type))) {
  }
  tgfx::fbs::LayerStyleType type() const {
    return static_cast<tgfx::fbs::LayerStyleType>(::flatbuffers::EndianScalar(type_));
  }
  tgfx::fbs::BlendMode blend_mode() const {
    return static_cast<tgfx::fbs::BlendMode>(::flatbuffers::EndianScalar(blend_mode_));
  }
  tgfx::fbs::LayerStylePosition position() const {
    return static_cast<tgfx::fbs::LayerStylePosition>(::flatbuffers::EndianScalar(position_));
  }
  tgfx::fbs::LayerStyleExtraSourceType source_type() const {
    return static_cast<tgfx::fbs::LayerStyleExtraSourceType>(::flatbuffers::EndianScalar(source_type_));
  }
};
FLATBUFFERS_STRUCT_END(LayerStyleCommonAttribute, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Color FLATBUFFERS_FINAL_CLASS {
 private:
  float red_;
  float green_;
  float blue_;
  float alpha_;

 public:
  Color()
      : red_(0),
        green_(0),
        blue_(0),
        alpha_(0) {
  }
  Color(float _red, float _green, float _blue, float _alpha)
      : red_(::flatbuffers::EndianScalar(_red)),
        green_(::flatbuffers::EndianScalar(_green)),
        blue_(::flatbuffers::EndianScalar(_blue)),
        alpha_(::flatbuffers::EndianScalar(_alpha)) {
  }
  float red() const {
    return ::flatbuffers::EndianScalar(red_);
  }
  float green() const {
    return ::flatbuffers::EndianScalar(green_);
  }
  float blue() const {
    return ::flatbuffers::EndianScalar(blue_);
  }
  float alpha() const {
    return ::flatbuffers::EndianScalar(alpha_);
  }
};
FLATBUFFERS_STRUCT_END(Color, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) LayerfilterCommonAttribute FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t type_;

 public:
  LayerfilterCommonAttribute()
      : type_(0) {
  }
  LayerfilterCommonAttribute(tgfx::fbs::LayerFilterType _type)
      : type_(::flatbuffers::EndianScalar(static_cast<int8_t>(_type))) {
  }
  tgfx::fbs::LayerFilterType type() const {
    return static_cast<tgfx::fbs::LayerFilterType>(::flatbuffers::EndianScalar(type_));
  }
};
FLATBUFFERS_STRUCT_END(LayerfilterCommonAttribute, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix FLATBUFFERS_FINAL_CLASS {
 private:
  float elements_[20];

 public:
  Matrix()
      : elements_() {
  }
  Matrix(::flatbuffers::span<const float, 20> _elements) {
    ::flatbuffers::CastToArray(elements_).CopyFromSpan(_elements);
  }
  const ::flatbuffers::Array<float, 20> *elements() const {
    return &::flatbuffers::CastToArray(elements_);
  }
};
FLATBUFFERS_STRUCT_END(Matrix, 80);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Point FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Point()
      : x_(0),
        y_(0) {
  }
  Point(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Point, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ImageAttribute FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t image_type_;
  int32_t image_width_;
  int32_t image_height_;
  uint8_t image_alpha_only_;
  uint8_t image_mipmap_;
  uint8_t image_fully_decode_;
  uint8_t image_texture_backed_;

 public:
  ImageAttribute()
      : image_type_(0),
        image_width_(0),
        image_height_(0),
        image_alpha_only_(0),
        image_mipmap_(0),
        image_fully_decode_(0),
        image_texture_backed_(0) {
  }
  ImageAttribute(int32_t _image_type, int32_t _image_width, int32_t _image_height, bool _image_alpha_only, bool _image_mipmap, bool _image_fully_decode, bool _image_texture_backed)
      : image_type_(::flatbuffers::EndianScalar(_image_type)),
        image_width_(::flatbuffers::EndianScalar(_image_width)),
        image_height_(::flatbuffers::EndianScalar(_image_height)),
        image_alpha_only_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_image_alpha_only))),
        image_mipmap_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_image_mipmap))),
        image_fully_decode_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_image_fully_decode))),
        image_texture_backed_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_image_texture_backed))) {
  }
  int32_t image_type() const {
    return ::flatbuffers::EndianScalar(image_type_);
  }
  int32_t image_width() const {
    return ::flatbuffers::EndianScalar(image_width_);
  }
  int32_t image_height() const {
    return ::flatbuffers::EndianScalar(image_height_);
  }
  bool image_alpha_only() const {
    return ::flatbuffers::EndianScalar(image_alpha_only_) != 0;
  }
  bool image_mipmap() const {
    return ::flatbuffers::EndianScalar(image_mipmap_) != 0;
  }
  bool image_fully_decode() const {
    return ::flatbuffers::EndianScalar(image_fully_decode_) != 0;
  }
  bool image_texture_backed() const {
    return ::flatbuffers::EndianScalar(image_texture_backed_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(ImageAttribute, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ShapeStyleCommonAttribute FLATBUFFERS_FINAL_CLASS {
 private:
  float shape_style_alpha_;
  int8_t blend_mode_;
  int8_t padding0__;  int16_t padding1__;

 public:
  ShapeStyleCommonAttribute()
      : shape_style_alpha_(0),
        blend_mode_(0),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  ShapeStyleCommonAttribute(float _shape_style_alpha, tgfx::fbs::BlendMode _blend_mode)
      : shape_style_alpha_(::flatbuffers::EndianScalar(_shape_style_alpha)),
        blend_mode_(::flatbuffers::EndianScalar(static_cast<int8_t>(_blend_mode))),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  float shape_style_alpha() const {
    return ::flatbuffers::EndianScalar(shape_style_alpha_);
  }
  tgfx::fbs::BlendMode blend_mode() const {
    return static_cast<tgfx::fbs::BlendMode>(::flatbuffers::EndianScalar(blend_mode_));
  }
};
FLATBUFFERS_STRUCT_END(ShapeStyleCommonAttribute, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Rect FLATBUFFERS_FINAL_CLASS {
 private:
  float left_;
  float top_;
  float right_;
  float bottom_;

 public:
  Rect()
      : left_(0),
        top_(0),
        right_(0),
        bottom_(0) {
  }
  Rect(float _left, float _top, float _right, float _bottom)
      : left_(::flatbuffers::EndianScalar(_left)),
        top_(::flatbuffers::EndianScalar(_top)),
        right_(::flatbuffers::EndianScalar(_right)),
        bottom_(::flatbuffers::EndianScalar(_bottom)) {
  }
  float left() const {
    return ::flatbuffers::EndianScalar(left_);
  }
  float top() const {
    return ::flatbuffers::EndianScalar(top_);
  }
  float right() const {
    return ::flatbuffers::EndianScalar(right_);
  }
  float bottom() const {
    return ::flatbuffers::EndianScalar(bottom_);
  }
};
FLATBUFFERS_STRUCT_END(Rect, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) FontMetrics FLATBUFFERS_FINAL_CLASS {
 private:
  float top_;
  float ascent_;
  float descent_;
  float bottom_;
  float leading_;
  float x_min_;
  float x_max_;
  float x_height_;
  float cap_height_;
  float underline_thickness_;
  float underline_position_;

 public:
  FontMetrics()
      : top_(0),
        ascent_(0),
        descent_(0),
        bottom_(0),
        leading_(0),
        x_min_(0),
        x_max_(0),
        x_height_(0),
        cap_height_(0),
        underline_thickness_(0),
        underline_position_(0) {
  }
  FontMetrics(float _top, float _ascent, float _descent, float _bottom, float _leading, float _x_min, float _x_max, float _x_height, float _cap_height, float _underline_thickness, float _underline_position)
      : top_(::flatbuffers::EndianScalar(_top)),
        ascent_(::flatbuffers::EndianScalar(_ascent)),
        descent_(::flatbuffers::EndianScalar(_descent)),
        bottom_(::flatbuffers::EndianScalar(_bottom)),
        leading_(::flatbuffers::EndianScalar(_leading)),
        x_min_(::flatbuffers::EndianScalar(_x_min)),
        x_max_(::flatbuffers::EndianScalar(_x_max)),
        x_height_(::flatbuffers::EndianScalar(_x_height)),
        cap_height_(::flatbuffers::EndianScalar(_cap_height)),
        underline_thickness_(::flatbuffers::EndianScalar(_underline_thickness)),
        underline_position_(::flatbuffers::EndianScalar(_underline_position)) {
  }
  float top() const {
    return ::flatbuffers::EndianScalar(top_);
  }
  float ascent() const {
    return ::flatbuffers::EndianScalar(ascent_);
  }
  float descent() const {
    return ::flatbuffers::EndianScalar(descent_);
  }
  float bottom() const {
    return ::flatbuffers::EndianScalar(bottom_);
  }
  float leading() const {
    return ::flatbuffers::EndianScalar(leading_);
  }
  float x_min() const {
    return ::flatbuffers::EndianScalar(x_min_);
  }
  float x_max() const {
    return ::flatbuffers::EndianScalar(x_max_);
  }
  float x_height() const {
    return ::flatbuffers::EndianScalar(x_height_);
  }
  float cap_height() const {
    return ::flatbuffers::EndianScalar(cap_height_);
  }
  float underline_thickness() const {
    return ::flatbuffers::EndianScalar(underline_thickness_);
  }
  float underline_position() const {
    return ::flatbuffers::EndianScalar(underline_position_);
  }
};
FLATBUFFERS_STRUCT_END(FontMetrics, 44);

struct BackGroundBlurStyleAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BackGroundBlurStyleAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_BLURRINESS_X = 6,
    VT_BLURRINESS_Y = 8,
    VT_TILE_MODE = 10
  };
  const tgfx::fbs::LayerStyleCommonAttribute *common_attribute() const {
    return GetStruct<const tgfx::fbs::LayerStyleCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  float blurriness_x() const {
    return GetField<float>(VT_BLURRINESS_X, 0.0f);
  }
  float blurriness_y() const {
    return GetField<float>(VT_BLURRINESS_Y, 0.0f);
  }
  tgfx::fbs::TileMode tile_mode() const {
    return static_cast<tgfx::fbs::TileMode>(GetField<int8_t>(VT_TILE_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<tgfx::fbs::LayerStyleCommonAttribute>(verifier, VT_COMMON_ATTRIBUTE, 1) &&
           VerifyField<float>(verifier, VT_BLURRINESS_X, 4) &&
           VerifyField<float>(verifier, VT_BLURRINESS_Y, 4) &&
           VerifyField<int8_t>(verifier, VT_TILE_MODE, 1) &&
           verifier.EndTable();
  }
};

struct BackGroundBlurStyleAttributeBuilder {
  typedef BackGroundBlurStyleAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(const tgfx::fbs::LayerStyleCommonAttribute *common_attribute) {
    fbb_.AddStruct(BackGroundBlurStyleAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_blurriness_x(float blurriness_x) {
    fbb_.AddElement<float>(BackGroundBlurStyleAttribute::VT_BLURRINESS_X, blurriness_x, 0.0f);
  }
  void add_blurriness_y(float blurriness_y) {
    fbb_.AddElement<float>(BackGroundBlurStyleAttribute::VT_BLURRINESS_Y, blurriness_y, 0.0f);
  }
  void add_tile_mode(tgfx::fbs::TileMode tile_mode) {
    fbb_.AddElement<int8_t>(BackGroundBlurStyleAttribute::VT_TILE_MODE, static_cast<int8_t>(tile_mode), 0);
  }
  explicit BackGroundBlurStyleAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BackGroundBlurStyleAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BackGroundBlurStyleAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BackGroundBlurStyleAttribute> CreateBackGroundBlurStyleAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const tgfx::fbs::LayerStyleCommonAttribute *common_attribute = nullptr,
    float blurriness_x = 0.0f,
    float blurriness_y = 0.0f,
    tgfx::fbs::TileMode tile_mode = tgfx::fbs::TileMode_Clamp) {
  BackGroundBlurStyleAttributeBuilder builder_(_fbb);
  builder_.add_blurriness_y(blurriness_y);
  builder_.add_blurriness_x(blurriness_x);
  builder_.add_common_attribute(common_attribute);
  builder_.add_tile_mode(tile_mode);
  return builder_.Finish();
}

struct DropShadowStyleAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DropShadowStyleAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_OFFSET_X = 6,
    VT_OFFSET_Y = 8,
    VT_BLURRINESS_X = 10,
    VT_BLURRINESS_Y = 12,
    VT_COLOR = 14,
    VT_SHOW_BEHIND_LAYER = 16
  };
  const tgfx::fbs::LayerStyleCommonAttribute *common_attribute() const {
    return GetStruct<const tgfx::fbs::LayerStyleCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  float offset_x() const {
    return GetField<float>(VT_OFFSET_X, 0.0f);
  }
  float offset_y() const {
    return GetField<float>(VT_OFFSET_Y, 0.0f);
  }
  float blurriness_x() const {
    return GetField<float>(VT_BLURRINESS_X, 0.0f);
  }
  float blurriness_y() const {
    return GetField<float>(VT_BLURRINESS_Y, 0.0f);
  }
  const tgfx::fbs::Color *color() const {
    return GetStruct<const tgfx::fbs::Color *>(VT_COLOR);
  }
  bool show_behind_layer() const {
    return GetField<uint8_t>(VT_SHOW_BEHIND_LAYER, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<tgfx::fbs::LayerStyleCommonAttribute>(verifier, VT_COMMON_ATTRIBUTE, 1) &&
           VerifyField<float>(verifier, VT_OFFSET_X, 4) &&
           VerifyField<float>(verifier, VT_OFFSET_Y, 4) &&
           VerifyField<float>(verifier, VT_BLURRINESS_X, 4) &&
           VerifyField<float>(verifier, VT_BLURRINESS_Y, 4) &&
           VerifyField<tgfx::fbs::Color>(verifier, VT_COLOR, 4) &&
           VerifyField<uint8_t>(verifier, VT_SHOW_BEHIND_LAYER, 1) &&
           verifier.EndTable();
  }
};

struct DropShadowStyleAttributeBuilder {
  typedef DropShadowStyleAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(const tgfx::fbs::LayerStyleCommonAttribute *common_attribute) {
    fbb_.AddStruct(DropShadowStyleAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_offset_x(float offset_x) {
    fbb_.AddElement<float>(DropShadowStyleAttribute::VT_OFFSET_X, offset_x, 0.0f);
  }
  void add_offset_y(float offset_y) {
    fbb_.AddElement<float>(DropShadowStyleAttribute::VT_OFFSET_Y, offset_y, 0.0f);
  }
  void add_blurriness_x(float blurriness_x) {
    fbb_.AddElement<float>(DropShadowStyleAttribute::VT_BLURRINESS_X, blurriness_x, 0.0f);
  }
  void add_blurriness_y(float blurriness_y) {
    fbb_.AddElement<float>(DropShadowStyleAttribute::VT_BLURRINESS_Y, blurriness_y, 0.0f);
  }
  void add_color(const tgfx::fbs::Color *color) {
    fbb_.AddStruct(DropShadowStyleAttribute::VT_COLOR, color);
  }
  void add_show_behind_layer(bool show_behind_layer) {
    fbb_.AddElement<uint8_t>(DropShadowStyleAttribute::VT_SHOW_BEHIND_LAYER, static_cast<uint8_t>(show_behind_layer), 0);
  }
  explicit DropShadowStyleAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DropShadowStyleAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DropShadowStyleAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DropShadowStyleAttribute> CreateDropShadowStyleAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const tgfx::fbs::LayerStyleCommonAttribute *common_attribute = nullptr,
    float offset_x = 0.0f,
    float offset_y = 0.0f,
    float blurriness_x = 0.0f,
    float blurriness_y = 0.0f,
    const tgfx::fbs::Color *color = nullptr,
    bool show_behind_layer = false) {
  DropShadowStyleAttributeBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_blurriness_y(blurriness_y);
  builder_.add_blurriness_x(blurriness_x);
  builder_.add_offset_y(offset_y);
  builder_.add_offset_x(offset_x);
  builder_.add_common_attribute(common_attribute);
  builder_.add_show_behind_layer(show_behind_layer);
  return builder_.Finish();
}

struct InnerShadowStyleAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InnerShadowStyleAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_OFFSET_X = 6,
    VT_OFFSET_Y = 8,
    VT_BLURRINESS_X = 10,
    VT_BLURRINESS_Y = 12,
    VT_COLOR = 14
  };
  const tgfx::fbs::LayerStyleCommonAttribute *common_attribute() const {
    return GetStruct<const tgfx::fbs::LayerStyleCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  float offset_x() const {
    return GetField<float>(VT_OFFSET_X, 0.0f);
  }
  float offset_y() const {
    return GetField<float>(VT_OFFSET_Y, 0.0f);
  }
  float blurriness_x() const {
    return GetField<float>(VT_BLURRINESS_X, 0.0f);
  }
  float blurriness_y() const {
    return GetField<float>(VT_BLURRINESS_Y, 0.0f);
  }
  const tgfx::fbs::Color *color() const {
    return GetStruct<const tgfx::fbs::Color *>(VT_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<tgfx::fbs::LayerStyleCommonAttribute>(verifier, VT_COMMON_ATTRIBUTE, 1) &&
           VerifyField<float>(verifier, VT_OFFSET_X, 4) &&
           VerifyField<float>(verifier, VT_OFFSET_Y, 4) &&
           VerifyField<float>(verifier, VT_BLURRINESS_X, 4) &&
           VerifyField<float>(verifier, VT_BLURRINESS_Y, 4) &&
           VerifyField<tgfx::fbs::Color>(verifier, VT_COLOR, 4) &&
           verifier.EndTable();
  }
};

struct InnerShadowStyleAttributeBuilder {
  typedef InnerShadowStyleAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(const tgfx::fbs::LayerStyleCommonAttribute *common_attribute) {
    fbb_.AddStruct(InnerShadowStyleAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_offset_x(float offset_x) {
    fbb_.AddElement<float>(InnerShadowStyleAttribute::VT_OFFSET_X, offset_x, 0.0f);
  }
  void add_offset_y(float offset_y) {
    fbb_.AddElement<float>(InnerShadowStyleAttribute::VT_OFFSET_Y, offset_y, 0.0f);
  }
  void add_blurriness_x(float blurriness_x) {
    fbb_.AddElement<float>(InnerShadowStyleAttribute::VT_BLURRINESS_X, blurriness_x, 0.0f);
  }
  void add_blurriness_y(float blurriness_y) {
    fbb_.AddElement<float>(InnerShadowStyleAttribute::VT_BLURRINESS_Y, blurriness_y, 0.0f);
  }
  void add_color(const tgfx::fbs::Color *color) {
    fbb_.AddStruct(InnerShadowStyleAttribute::VT_COLOR, color);
  }
  explicit InnerShadowStyleAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InnerShadowStyleAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InnerShadowStyleAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InnerShadowStyleAttribute> CreateInnerShadowStyleAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const tgfx::fbs::LayerStyleCommonAttribute *common_attribute = nullptr,
    float offset_x = 0.0f,
    float offset_y = 0.0f,
    float blurriness_x = 0.0f,
    float blurriness_y = 0.0f,
    const tgfx::fbs::Color *color = nullptr) {
  InnerShadowStyleAttributeBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_blurriness_y(blurriness_y);
  builder_.add_blurriness_x(blurriness_x);
  builder_.add_offset_y(offset_y);
  builder_.add_offset_x(offset_x);
  builder_.add_common_attribute(common_attribute);
  return builder_.Finish();
}

struct BlendFilterAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BlendFilterAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_COLOR = 6,
    VT_BLEND_MODE = 8
  };
  const tgfx::fbs::LayerfilterCommonAttribute *common_attribute() const {
    return GetStruct<const tgfx::fbs::LayerfilterCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  const tgfx::fbs::Color *color() const {
    return GetStruct<const tgfx::fbs::Color *>(VT_COLOR);
  }
  tgfx::fbs::BlendMode blend_mode() const {
    return static_cast<tgfx::fbs::BlendMode>(GetField<int8_t>(VT_BLEND_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<tgfx::fbs::LayerfilterCommonAttribute>(verifier, VT_COMMON_ATTRIBUTE, 1) &&
           VerifyField<tgfx::fbs::Color>(verifier, VT_COLOR, 4) &&
           VerifyField<int8_t>(verifier, VT_BLEND_MODE, 1) &&
           verifier.EndTable();
  }
};

struct BlendFilterAttributeBuilder {
  typedef BlendFilterAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(const tgfx::fbs::LayerfilterCommonAttribute *common_attribute) {
    fbb_.AddStruct(BlendFilterAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_color(const tgfx::fbs::Color *color) {
    fbb_.AddStruct(BlendFilterAttribute::VT_COLOR, color);
  }
  void add_blend_mode(tgfx::fbs::BlendMode blend_mode) {
    fbb_.AddElement<int8_t>(BlendFilterAttribute::VT_BLEND_MODE, static_cast<int8_t>(blend_mode), 0);
  }
  explicit BlendFilterAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlendFilterAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlendFilterAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlendFilterAttribute> CreateBlendFilterAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const tgfx::fbs::LayerfilterCommonAttribute *common_attribute = nullptr,
    const tgfx::fbs::Color *color = nullptr,
    tgfx::fbs::BlendMode blend_mode = tgfx::fbs::BlendMode_Clear) {
  BlendFilterAttributeBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_common_attribute(common_attribute);
  builder_.add_blend_mode(blend_mode);
  return builder_.Finish();
}

struct BlurFilterAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BlurFilterAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_BLURRINESS_X = 6,
    VT_BLURRINESS_Y = 8,
    VT_TILE_MODE = 10
  };
  const tgfx::fbs::LayerfilterCommonAttribute *common_attribute() const {
    return GetStruct<const tgfx::fbs::LayerfilterCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  float blurriness_x() const {
    return GetField<float>(VT_BLURRINESS_X, 0.0f);
  }
  float blurriness_y() const {
    return GetField<float>(VT_BLURRINESS_Y, 0.0f);
  }
  tgfx::fbs::TileMode tile_mode() const {
    return static_cast<tgfx::fbs::TileMode>(GetField<int8_t>(VT_TILE_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<tgfx::fbs::LayerfilterCommonAttribute>(verifier, VT_COMMON_ATTRIBUTE, 1) &&
           VerifyField<float>(verifier, VT_BLURRINESS_X, 4) &&
           VerifyField<float>(verifier, VT_BLURRINESS_Y, 4) &&
           VerifyField<int8_t>(verifier, VT_TILE_MODE, 1) &&
           verifier.EndTable();
  }
};

struct BlurFilterAttributeBuilder {
  typedef BlurFilterAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(const tgfx::fbs::LayerfilterCommonAttribute *common_attribute) {
    fbb_.AddStruct(BlurFilterAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_blurriness_x(float blurriness_x) {
    fbb_.AddElement<float>(BlurFilterAttribute::VT_BLURRINESS_X, blurriness_x, 0.0f);
  }
  void add_blurriness_y(float blurriness_y) {
    fbb_.AddElement<float>(BlurFilterAttribute::VT_BLURRINESS_Y, blurriness_y, 0.0f);
  }
  void add_tile_mode(tgfx::fbs::TileMode tile_mode) {
    fbb_.AddElement<int8_t>(BlurFilterAttribute::VT_TILE_MODE, static_cast<int8_t>(tile_mode), 0);
  }
  explicit BlurFilterAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BlurFilterAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BlurFilterAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BlurFilterAttribute> CreateBlurFilterAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const tgfx::fbs::LayerfilterCommonAttribute *common_attribute = nullptr,
    float blurriness_x = 0.0f,
    float blurriness_y = 0.0f,
    tgfx::fbs::TileMode tile_mode = tgfx::fbs::TileMode_Clamp) {
  BlurFilterAttributeBuilder builder_(_fbb);
  builder_.add_blurriness_y(blurriness_y);
  builder_.add_blurriness_x(blurriness_x);
  builder_.add_common_attribute(common_attribute);
  builder_.add_tile_mode(tile_mode);
  return builder_.Finish();
}

struct ColorFilterAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColorFilterAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_MATRIX = 6
  };
  const tgfx::fbs::LayerfilterCommonAttribute *common_attribute() const {
    return GetStruct<const tgfx::fbs::LayerfilterCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  const tgfx::fbs::Matrix *matrix() const {
    return GetStruct<const tgfx::fbs::Matrix *>(VT_MATRIX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<tgfx::fbs::LayerfilterCommonAttribute>(verifier, VT_COMMON_ATTRIBUTE, 1) &&
           VerifyField<tgfx::fbs::Matrix>(verifier, VT_MATRIX, 4) &&
           verifier.EndTable();
  }
};

struct ColorFilterAttributeBuilder {
  typedef ColorFilterAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(const tgfx::fbs::LayerfilterCommonAttribute *common_attribute) {
    fbb_.AddStruct(ColorFilterAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_matrix(const tgfx::fbs::Matrix *matrix) {
    fbb_.AddStruct(ColorFilterAttribute::VT_MATRIX, matrix);
  }
  explicit ColorFilterAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColorFilterAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColorFilterAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ColorFilterAttribute> CreateColorFilterAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const tgfx::fbs::LayerfilterCommonAttribute *common_attribute = nullptr,
    const tgfx::fbs::Matrix *matrix = nullptr) {
  ColorFilterAttributeBuilder builder_(_fbb);
  builder_.add_matrix(matrix);
  builder_.add_common_attribute(common_attribute);
  return builder_.Finish();
}

struct DropShadowFilterAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DropShadowFilterAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_OFFSET_X = 6,
    VT_OFFSET_Y = 8,
    VT_BLURRINESS_X = 10,
    VT_BLURRINESS_Y = 12,
    VT_COLOR = 14,
    VT_DROP_SHADOW_ONLY = 16
  };
  const tgfx::fbs::LayerfilterCommonAttribute *common_attribute() const {
    return GetStruct<const tgfx::fbs::LayerfilterCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  float offset_x() const {
    return GetField<float>(VT_OFFSET_X, 0.0f);
  }
  float offset_y() const {
    return GetField<float>(VT_OFFSET_Y, 0.0f);
  }
  float blurriness_x() const {
    return GetField<float>(VT_BLURRINESS_X, 0.0f);
  }
  float blurriness_y() const {
    return GetField<float>(VT_BLURRINESS_Y, 0.0f);
  }
  const tgfx::fbs::Color *color() const {
    return GetStruct<const tgfx::fbs::Color *>(VT_COLOR);
  }
  bool drop_shadow_only() const {
    return GetField<uint8_t>(VT_DROP_SHADOW_ONLY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<tgfx::fbs::LayerfilterCommonAttribute>(verifier, VT_COMMON_ATTRIBUTE, 1) &&
           VerifyField<float>(verifier, VT_OFFSET_X, 4) &&
           VerifyField<float>(verifier, VT_OFFSET_Y, 4) &&
           VerifyField<float>(verifier, VT_BLURRINESS_X, 4) &&
           VerifyField<float>(verifier, VT_BLURRINESS_Y, 4) &&
           VerifyField<tgfx::fbs::Color>(verifier, VT_COLOR, 4) &&
           VerifyField<uint8_t>(verifier, VT_DROP_SHADOW_ONLY, 1) &&
           verifier.EndTable();
  }
};

struct DropShadowFilterAttributeBuilder {
  typedef DropShadowFilterAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(const tgfx::fbs::LayerfilterCommonAttribute *common_attribute) {
    fbb_.AddStruct(DropShadowFilterAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_offset_x(float offset_x) {
    fbb_.AddElement<float>(DropShadowFilterAttribute::VT_OFFSET_X, offset_x, 0.0f);
  }
  void add_offset_y(float offset_y) {
    fbb_.AddElement<float>(DropShadowFilterAttribute::VT_OFFSET_Y, offset_y, 0.0f);
  }
  void add_blurriness_x(float blurriness_x) {
    fbb_.AddElement<float>(DropShadowFilterAttribute::VT_BLURRINESS_X, blurriness_x, 0.0f);
  }
  void add_blurriness_y(float blurriness_y) {
    fbb_.AddElement<float>(DropShadowFilterAttribute::VT_BLURRINESS_Y, blurriness_y, 0.0f);
  }
  void add_color(const tgfx::fbs::Color *color) {
    fbb_.AddStruct(DropShadowFilterAttribute::VT_COLOR, color);
  }
  void add_drop_shadow_only(bool drop_shadow_only) {
    fbb_.AddElement<uint8_t>(DropShadowFilterAttribute::VT_DROP_SHADOW_ONLY, static_cast<uint8_t>(drop_shadow_only), 0);
  }
  explicit DropShadowFilterAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DropShadowFilterAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DropShadowFilterAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DropShadowFilterAttribute> CreateDropShadowFilterAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const tgfx::fbs::LayerfilterCommonAttribute *common_attribute = nullptr,
    float offset_x = 0.0f,
    float offset_y = 0.0f,
    float blurriness_x = 0.0f,
    float blurriness_y = 0.0f,
    const tgfx::fbs::Color *color = nullptr,
    bool drop_shadow_only = false) {
  DropShadowFilterAttributeBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_blurriness_y(blurriness_y);
  builder_.add_blurriness_x(blurriness_x);
  builder_.add_offset_y(offset_y);
  builder_.add_offset_x(offset_x);
  builder_.add_common_attribute(common_attribute);
  builder_.add_drop_shadow_only(drop_shadow_only);
  return builder_.Finish();
}

struct InnerShadowFilterAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InnerShadowFilterAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_OFFSET_X = 6,
    VT_OFFSET_Y = 8,
    VT_BLURRINESS_X = 10,
    VT_BLURRINESS_Y = 12,
    VT_COLOR = 14,
    VT_INNER_SHADOW_ONLY = 16
  };
  const tgfx::fbs::LayerfilterCommonAttribute *common_attribute() const {
    return GetStruct<const tgfx::fbs::LayerfilterCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  float offset_x() const {
    return GetField<float>(VT_OFFSET_X, 0.0f);
  }
  float offset_y() const {
    return GetField<float>(VT_OFFSET_Y, 0.0f);
  }
  float blurriness_x() const {
    return GetField<float>(VT_BLURRINESS_X, 0.0f);
  }
  float blurriness_y() const {
    return GetField<float>(VT_BLURRINESS_Y, 0.0f);
  }
  const tgfx::fbs::Color *color() const {
    return GetStruct<const tgfx::fbs::Color *>(VT_COLOR);
  }
  bool inner_shadow_only() const {
    return GetField<uint8_t>(VT_INNER_SHADOW_ONLY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<tgfx::fbs::LayerfilterCommonAttribute>(verifier, VT_COMMON_ATTRIBUTE, 1) &&
           VerifyField<float>(verifier, VT_OFFSET_X, 4) &&
           VerifyField<float>(verifier, VT_OFFSET_Y, 4) &&
           VerifyField<float>(verifier, VT_BLURRINESS_X, 4) &&
           VerifyField<float>(verifier, VT_BLURRINESS_Y, 4) &&
           VerifyField<tgfx::fbs::Color>(verifier, VT_COLOR, 4) &&
           VerifyField<uint8_t>(verifier, VT_INNER_SHADOW_ONLY, 1) &&
           verifier.EndTable();
  }
};

struct InnerShadowFilterAttributeBuilder {
  typedef InnerShadowFilterAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(const tgfx::fbs::LayerfilterCommonAttribute *common_attribute) {
    fbb_.AddStruct(InnerShadowFilterAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_offset_x(float offset_x) {
    fbb_.AddElement<float>(InnerShadowFilterAttribute::VT_OFFSET_X, offset_x, 0.0f);
  }
  void add_offset_y(float offset_y) {
    fbb_.AddElement<float>(InnerShadowFilterAttribute::VT_OFFSET_Y, offset_y, 0.0f);
  }
  void add_blurriness_x(float blurriness_x) {
    fbb_.AddElement<float>(InnerShadowFilterAttribute::VT_BLURRINESS_X, blurriness_x, 0.0f);
  }
  void add_blurriness_y(float blurriness_y) {
    fbb_.AddElement<float>(InnerShadowFilterAttribute::VT_BLURRINESS_Y, blurriness_y, 0.0f);
  }
  void add_color(const tgfx::fbs::Color *color) {
    fbb_.AddStruct(InnerShadowFilterAttribute::VT_COLOR, color);
  }
  void add_inner_shadow_only(bool inner_shadow_only) {
    fbb_.AddElement<uint8_t>(InnerShadowFilterAttribute::VT_INNER_SHADOW_ONLY, static_cast<uint8_t>(inner_shadow_only), 0);
  }
  explicit InnerShadowFilterAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InnerShadowFilterAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InnerShadowFilterAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InnerShadowFilterAttribute> CreateInnerShadowFilterAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const tgfx::fbs::LayerfilterCommonAttribute *common_attribute = nullptr,
    float offset_x = 0.0f,
    float offset_y = 0.0f,
    float blurriness_x = 0.0f,
    float blurriness_y = 0.0f,
    const tgfx::fbs::Color *color = nullptr,
    bool inner_shadow_only = false) {
  InnerShadowFilterAttributeBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_blurriness_y(blurriness_y);
  builder_.add_blurriness_x(blurriness_x);
  builder_.add_offset_y(offset_y);
  builder_.add_offset_x(offset_x);
  builder_.add_common_attribute(common_attribute);
  builder_.add_inner_shadow_only(inner_shadow_only);
  return builder_.Finish();
}

struct LayerStyle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayerStyleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STYLE_TYPE = 4,
    VT_STYLE_BODY_TYPE = 6,
    VT_STYLE_BODY = 8
  };
  tgfx::fbs::LayerStyleType style_type() const {
    return static_cast<tgfx::fbs::LayerStyleType>(GetField<int8_t>(VT_STYLE_TYPE, 0));
  }
  tgfx::fbs::LayerStyleAttribute style_body_type() const {
    return static_cast<tgfx::fbs::LayerStyleAttribute>(GetField<uint8_t>(VT_STYLE_BODY_TYPE, 0));
  }
  const void *style_body() const {
    return GetPointer<const void *>(VT_STYLE_BODY);
  }
  template<typename T> const T *style_body_as() const;
  const tgfx::fbs::BackGroundBlurStyleAttribute *style_body_as_BackGroundBlurStyleAttribute() const {
    return style_body_type() == tgfx::fbs::LayerStyleAttribute_BackGroundBlurStyleAttribute ? static_cast<const tgfx::fbs::BackGroundBlurStyleAttribute *>(style_body()) : nullptr;
  }
  const tgfx::fbs::DropShadowStyleAttribute *style_body_as_DropShadowStyleAttribute() const {
    return style_body_type() == tgfx::fbs::LayerStyleAttribute_DropShadowStyleAttribute ? static_cast<const tgfx::fbs::DropShadowStyleAttribute *>(style_body()) : nullptr;
  }
  const tgfx::fbs::InnerShadowStyleAttribute *style_body_as_InnerShadowStyleAttribute() const {
    return style_body_type() == tgfx::fbs::LayerStyleAttribute_InnerShadowStyleAttribute ? static_cast<const tgfx::fbs::InnerShadowStyleAttribute *>(style_body()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STYLE_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_STYLE_BODY_TYPE, 1) &&
           VerifyOffset(verifier, VT_STYLE_BODY) &&
           VerifyLayerStyleAttribute(verifier, style_body(), style_body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const tgfx::fbs::BackGroundBlurStyleAttribute *LayerStyle::style_body_as<tgfx::fbs::BackGroundBlurStyleAttribute>() const {
  return style_body_as_BackGroundBlurStyleAttribute();
}

template<> inline const tgfx::fbs::DropShadowStyleAttribute *LayerStyle::style_body_as<tgfx::fbs::DropShadowStyleAttribute>() const {
  return style_body_as_DropShadowStyleAttribute();
}

template<> inline const tgfx::fbs::InnerShadowStyleAttribute *LayerStyle::style_body_as<tgfx::fbs::InnerShadowStyleAttribute>() const {
  return style_body_as_InnerShadowStyleAttribute();
}

struct LayerStyleBuilder {
  typedef LayerStyle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_style_type(tgfx::fbs::LayerStyleType style_type) {
    fbb_.AddElement<int8_t>(LayerStyle::VT_STYLE_TYPE, static_cast<int8_t>(style_type), 0);
  }
  void add_style_body_type(tgfx::fbs::LayerStyleAttribute style_body_type) {
    fbb_.AddElement<uint8_t>(LayerStyle::VT_STYLE_BODY_TYPE, static_cast<uint8_t>(style_body_type), 0);
  }
  void add_style_body(::flatbuffers::Offset<void> style_body) {
    fbb_.AddOffset(LayerStyle::VT_STYLE_BODY, style_body);
  }
  explicit LayerStyleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LayerStyle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LayerStyle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LayerStyle> CreateLayerStyle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tgfx::fbs::LayerStyleType style_type = tgfx::fbs::LayerStyleType_BackgroundBlur,
    tgfx::fbs::LayerStyleAttribute style_body_type = tgfx::fbs::LayerStyleAttribute_NONE,
    ::flatbuffers::Offset<void> style_body = 0) {
  LayerStyleBuilder builder_(_fbb);
  builder_.add_style_body(style_body);
  builder_.add_style_body_type(style_body_type);
  builder_.add_style_type(style_type);
  return builder_.Finish();
}

struct LayerFilter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayerFilterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILTER_TYPE = 4,
    VT_FILTER_BODY_TYPE = 6,
    VT_FILTER_BODY = 8
  };
  tgfx::fbs::LayerFilterType filter_type() const {
    return static_cast<tgfx::fbs::LayerFilterType>(GetField<int8_t>(VT_FILTER_TYPE, 0));
  }
  tgfx::fbs::LayerFilterAttribute filter_body_type() const {
    return static_cast<tgfx::fbs::LayerFilterAttribute>(GetField<uint8_t>(VT_FILTER_BODY_TYPE, 0));
  }
  const void *filter_body() const {
    return GetPointer<const void *>(VT_FILTER_BODY);
  }
  template<typename T> const T *filter_body_as() const;
  const tgfx::fbs::BlendFilterAttribute *filter_body_as_BlendFilterAttribute() const {
    return filter_body_type() == tgfx::fbs::LayerFilterAttribute_BlendFilterAttribute ? static_cast<const tgfx::fbs::BlendFilterAttribute *>(filter_body()) : nullptr;
  }
  const tgfx::fbs::BlurFilterAttribute *filter_body_as_BlurFilterAttribute() const {
    return filter_body_type() == tgfx::fbs::LayerFilterAttribute_BlurFilterAttribute ? static_cast<const tgfx::fbs::BlurFilterAttribute *>(filter_body()) : nullptr;
  }
  const tgfx::fbs::ColorFilterAttribute *filter_body_as_ColorFilterAttribute() const {
    return filter_body_type() == tgfx::fbs::LayerFilterAttribute_ColorFilterAttribute ? static_cast<const tgfx::fbs::ColorFilterAttribute *>(filter_body()) : nullptr;
  }
  const tgfx::fbs::DropShadowFilterAttribute *filter_body_as_DropShadowFilterAttribute() const {
    return filter_body_type() == tgfx::fbs::LayerFilterAttribute_DropShadowFilterAttribute ? static_cast<const tgfx::fbs::DropShadowFilterAttribute *>(filter_body()) : nullptr;
  }
  const tgfx::fbs::InnerShadowFilterAttribute *filter_body_as_InnerShadowFilterAttribute() const {
    return filter_body_type() == tgfx::fbs::LayerFilterAttribute_InnerShadowFilterAttribute ? static_cast<const tgfx::fbs::InnerShadowFilterAttribute *>(filter_body()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FILTER_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FILTER_BODY_TYPE, 1) &&
           VerifyOffset(verifier, VT_FILTER_BODY) &&
           VerifyLayerFilterAttribute(verifier, filter_body(), filter_body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const tgfx::fbs::BlendFilterAttribute *LayerFilter::filter_body_as<tgfx::fbs::BlendFilterAttribute>() const {
  return filter_body_as_BlendFilterAttribute();
}

template<> inline const tgfx::fbs::BlurFilterAttribute *LayerFilter::filter_body_as<tgfx::fbs::BlurFilterAttribute>() const {
  return filter_body_as_BlurFilterAttribute();
}

template<> inline const tgfx::fbs::ColorFilterAttribute *LayerFilter::filter_body_as<tgfx::fbs::ColorFilterAttribute>() const {
  return filter_body_as_ColorFilterAttribute();
}

template<> inline const tgfx::fbs::DropShadowFilterAttribute *LayerFilter::filter_body_as<tgfx::fbs::DropShadowFilterAttribute>() const {
  return filter_body_as_DropShadowFilterAttribute();
}

template<> inline const tgfx::fbs::InnerShadowFilterAttribute *LayerFilter::filter_body_as<tgfx::fbs::InnerShadowFilterAttribute>() const {
  return filter_body_as_InnerShadowFilterAttribute();
}

struct LayerFilterBuilder {
  typedef LayerFilter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filter_type(tgfx::fbs::LayerFilterType filter_type) {
    fbb_.AddElement<int8_t>(LayerFilter::VT_FILTER_TYPE, static_cast<int8_t>(filter_type), 0);
  }
  void add_filter_body_type(tgfx::fbs::LayerFilterAttribute filter_body_type) {
    fbb_.AddElement<uint8_t>(LayerFilter::VT_FILTER_BODY_TYPE, static_cast<uint8_t>(filter_body_type), 0);
  }
  void add_filter_body(::flatbuffers::Offset<void> filter_body) {
    fbb_.AddOffset(LayerFilter::VT_FILTER_BODY, filter_body);
  }
  explicit LayerFilterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LayerFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LayerFilter>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LayerFilter> CreateLayerFilter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tgfx::fbs::LayerFilterType filter_type = tgfx::fbs::LayerFilterType_LayerFilter,
    tgfx::fbs::LayerFilterAttribute filter_body_type = tgfx::fbs::LayerFilterAttribute_NONE,
    ::flatbuffers::Offset<void> filter_body = 0) {
  LayerFilterBuilder builder_(_fbb);
  builder_.add_filter_body(filter_body);
  builder_.add_filter_body_type(filter_body_type);
  builder_.add_filter_type(filter_type);
  return builder_.Finish();
}

struct LayerCommonAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayerCommonAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_ALPHA = 8,
    VT_BLEND_MODE = 10,
    VT_POSITION = 12,
    VT_VISIBLE = 14,
    VT_RASTERIZE = 16,
    VT_RASTERIZE_SCALE = 18,
    VT_EDGE_ANTIALIASING = 20,
    VT_GROUNP_OPACITY = 22,
    VT_LAYER_STYLES = 24,
    VT_LAYER_FILTERS = 26
  };
  tgfx::fbs::LayerType type() const {
    return static_cast<tgfx::fbs::LayerType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  tgfx::fbs::BlendMode blend_mode() const {
    return static_cast<tgfx::fbs::BlendMode>(GetField<int8_t>(VT_BLEND_MODE, 0));
  }
  const tgfx::fbs::Point *position() const {
    return GetStruct<const tgfx::fbs::Point *>(VT_POSITION);
  }
  bool visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  bool rasterize() const {
    return GetField<uint8_t>(VT_RASTERIZE, 0) != 0;
  }
  float rasterize_scale() const {
    return GetField<float>(VT_RASTERIZE_SCALE, 0.0f);
  }
  bool edge_antialiasing() const {
    return GetField<uint8_t>(VT_EDGE_ANTIALIASING, 0) != 0;
  }
  bool grounp_opacity() const {
    return GetField<uint8_t>(VT_GROUNP_OPACITY, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::LayerStyle>> *layer_styles() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::LayerStyle>> *>(VT_LAYER_STYLES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::LayerFilter>> *layer_filters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::LayerFilter>> *>(VT_LAYER_FILTERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<int8_t>(verifier, VT_BLEND_MODE, 1) &&
           VerifyField<tgfx::fbs::Point>(verifier, VT_POSITION, 4) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_RASTERIZE, 1) &&
           VerifyField<float>(verifier, VT_RASTERIZE_SCALE, 4) &&
           VerifyField<uint8_t>(verifier, VT_EDGE_ANTIALIASING, 1) &&
           VerifyField<uint8_t>(verifier, VT_GROUNP_OPACITY, 1) &&
           VerifyOffset(verifier, VT_LAYER_STYLES) &&
           verifier.VerifyVector(layer_styles()) &&
           verifier.VerifyVectorOfTables(layer_styles()) &&
           VerifyOffset(verifier, VT_LAYER_FILTERS) &&
           verifier.VerifyVector(layer_filters()) &&
           verifier.VerifyVectorOfTables(layer_filters()) &&
           verifier.EndTable();
  }
};

struct LayerCommonAttributeBuilder {
  typedef LayerCommonAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(tgfx::fbs::LayerType type) {
    fbb_.AddElement<int8_t>(LayerCommonAttribute::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(LayerCommonAttribute::VT_NAME, name);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LayerCommonAttribute::VT_ALPHA, alpha, 0.0f);
  }
  void add_blend_mode(tgfx::fbs::BlendMode blend_mode) {
    fbb_.AddElement<int8_t>(LayerCommonAttribute::VT_BLEND_MODE, static_cast<int8_t>(blend_mode), 0);
  }
  void add_position(const tgfx::fbs::Point *position) {
    fbb_.AddStruct(LayerCommonAttribute::VT_POSITION, position);
  }
  void add_visible(bool visible) {
    fbb_.AddElement<uint8_t>(LayerCommonAttribute::VT_VISIBLE, static_cast<uint8_t>(visible), 0);
  }
  void add_rasterize(bool rasterize) {
    fbb_.AddElement<uint8_t>(LayerCommonAttribute::VT_RASTERIZE, static_cast<uint8_t>(rasterize), 0);
  }
  void add_rasterize_scale(float rasterize_scale) {
    fbb_.AddElement<float>(LayerCommonAttribute::VT_RASTERIZE_SCALE, rasterize_scale, 0.0f);
  }
  void add_edge_antialiasing(bool edge_antialiasing) {
    fbb_.AddElement<uint8_t>(LayerCommonAttribute::VT_EDGE_ANTIALIASING, static_cast<uint8_t>(edge_antialiasing), 0);
  }
  void add_grounp_opacity(bool grounp_opacity) {
    fbb_.AddElement<uint8_t>(LayerCommonAttribute::VT_GROUNP_OPACITY, static_cast<uint8_t>(grounp_opacity), 0);
  }
  void add_layer_styles(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::LayerStyle>>> layer_styles) {
    fbb_.AddOffset(LayerCommonAttribute::VT_LAYER_STYLES, layer_styles);
  }
  void add_layer_filters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::LayerFilter>>> layer_filters) {
    fbb_.AddOffset(LayerCommonAttribute::VT_LAYER_FILTERS, layer_filters);
  }
  explicit LayerCommonAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LayerCommonAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LayerCommonAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LayerCommonAttribute> CreateLayerCommonAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tgfx::fbs::LayerType type = tgfx::fbs::LayerType_Layer,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    float alpha = 0.0f,
    tgfx::fbs::BlendMode blend_mode = tgfx::fbs::BlendMode_Clear,
    const tgfx::fbs::Point *position = nullptr,
    bool visible = false,
    bool rasterize = false,
    float rasterize_scale = 0.0f,
    bool edge_antialiasing = false,
    bool grounp_opacity = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::LayerStyle>>> layer_styles = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::LayerFilter>>> layer_filters = 0) {
  LayerCommonAttributeBuilder builder_(_fbb);
  builder_.add_layer_filters(layer_filters);
  builder_.add_layer_styles(layer_styles);
  builder_.add_rasterize_scale(rasterize_scale);
  builder_.add_position(position);
  builder_.add_alpha(alpha);
  builder_.add_name(name);
  builder_.add_grounp_opacity(grounp_opacity);
  builder_.add_edge_antialiasing(edge_antialiasing);
  builder_.add_rasterize(rasterize);
  builder_.add_visible(visible);
  builder_.add_blend_mode(blend_mode);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LayerCommonAttribute> CreateLayerCommonAttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tgfx::fbs::LayerType type = tgfx::fbs::LayerType_Layer,
    const char *name = nullptr,
    float alpha = 0.0f,
    tgfx::fbs::BlendMode blend_mode = tgfx::fbs::BlendMode_Clear,
    const tgfx::fbs::Point *position = nullptr,
    bool visible = false,
    bool rasterize = false,
    float rasterize_scale = 0.0f,
    bool edge_antialiasing = false,
    bool grounp_opacity = false,
    const std::vector<::flatbuffers::Offset<tgfx::fbs::LayerStyle>> *layer_styles = nullptr,
    const std::vector<::flatbuffers::Offset<tgfx::fbs::LayerFilter>> *layer_filters = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto layer_styles__ = layer_styles ? _fbb.CreateVector<::flatbuffers::Offset<tgfx::fbs::LayerStyle>>(*layer_styles) : 0;
  auto layer_filters__ = layer_filters ? _fbb.CreateVector<::flatbuffers::Offset<tgfx::fbs::LayerFilter>>(*layer_filters) : 0;
  return tgfx::fbs::CreateLayerCommonAttribute(
      _fbb,
      type,
      name__,
      alpha,
      blend_mode,
      position,
      visible,
      rasterize,
      rasterize_scale,
      edge_antialiasing,
      grounp_opacity,
      layer_styles__,
      layer_filters__);
}

struct ImageLayerAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImageLayerAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_FILTER_MODE = 6,
    VT_MIPMAP_MODE = 8,
    VT_IMAGE = 10
  };
  const tgfx::fbs::LayerCommonAttribute *common_attribute() const {
    return GetPointer<const tgfx::fbs::LayerCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  tgfx::fbs::FilterMode filter_mode() const {
    return static_cast<tgfx::fbs::FilterMode>(GetField<int8_t>(VT_FILTER_MODE, 0));
  }
  tgfx::fbs::MipmapMode mipmap_mode() const {
    return static_cast<tgfx::fbs::MipmapMode>(GetField<int8_t>(VT_MIPMAP_MODE, 0));
  }
  const tgfx::fbs::ImageAttribute *image() const {
    return GetStruct<const tgfx::fbs::ImageAttribute *>(VT_IMAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON_ATTRIBUTE) &&
           verifier.VerifyTable(common_attribute()) &&
           VerifyField<int8_t>(verifier, VT_FILTER_MODE, 1) &&
           VerifyField<int8_t>(verifier, VT_MIPMAP_MODE, 1) &&
           VerifyField<tgfx::fbs::ImageAttribute>(verifier, VT_IMAGE, 4) &&
           verifier.EndTable();
  }
};

struct ImageLayerAttributeBuilder {
  typedef ImageLayerAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(::flatbuffers::Offset<tgfx::fbs::LayerCommonAttribute> common_attribute) {
    fbb_.AddOffset(ImageLayerAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_filter_mode(tgfx::fbs::FilterMode filter_mode) {
    fbb_.AddElement<int8_t>(ImageLayerAttribute::VT_FILTER_MODE, static_cast<int8_t>(filter_mode), 0);
  }
  void add_mipmap_mode(tgfx::fbs::MipmapMode mipmap_mode) {
    fbb_.AddElement<int8_t>(ImageLayerAttribute::VT_MIPMAP_MODE, static_cast<int8_t>(mipmap_mode), 0);
  }
  void add_image(const tgfx::fbs::ImageAttribute *image) {
    fbb_.AddStruct(ImageLayerAttribute::VT_IMAGE, image);
  }
  explicit ImageLayerAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImageLayerAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImageLayerAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ImageLayerAttribute> CreateImageLayerAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tgfx::fbs::LayerCommonAttribute> common_attribute = 0,
    tgfx::fbs::FilterMode filter_mode = tgfx::fbs::FilterMode_Nearest,
    tgfx::fbs::MipmapMode mipmap_mode = tgfx::fbs::MipmapMode_None,
    const tgfx::fbs::ImageAttribute *image = nullptr) {
  ImageLayerAttributeBuilder builder_(_fbb);
  builder_.add_image(image);
  builder_.add_common_attribute(common_attribute);
  builder_.add_mipmap_mode(mipmap_mode);
  builder_.add_filter_mode(filter_mode);
  return builder_.Finish();
}

struct ImagePatternAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImagePatternAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_TILEMODE_X = 6,
    VT_TILEMODE_Y = 8,
    VT_FILTERMODE = 10,
    VT_MIPMAPMODE = 12,
    VT_IMAGE = 14
  };
  const tgfx::fbs::ShapeStyleCommonAttribute *common_attribute() const {
    return GetStruct<const tgfx::fbs::ShapeStyleCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  tgfx::fbs::TileMode tilemode_x() const {
    return static_cast<tgfx::fbs::TileMode>(GetField<int8_t>(VT_TILEMODE_X, 0));
  }
  tgfx::fbs::TileMode tilemode_y() const {
    return static_cast<tgfx::fbs::TileMode>(GetField<int8_t>(VT_TILEMODE_Y, 0));
  }
  tgfx::fbs::FilterMode filtermode() const {
    return static_cast<tgfx::fbs::FilterMode>(GetField<int8_t>(VT_FILTERMODE, 0));
  }
  tgfx::fbs::MipmapMode mipmapmode() const {
    return static_cast<tgfx::fbs::MipmapMode>(GetField<int8_t>(VT_MIPMAPMODE, 0));
  }
  const tgfx::fbs::ImageAttribute *image() const {
    return GetStruct<const tgfx::fbs::ImageAttribute *>(VT_IMAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<tgfx::fbs::ShapeStyleCommonAttribute>(verifier, VT_COMMON_ATTRIBUTE, 4) &&
           VerifyField<int8_t>(verifier, VT_TILEMODE_X, 1) &&
           VerifyField<int8_t>(verifier, VT_TILEMODE_Y, 1) &&
           VerifyField<int8_t>(verifier, VT_FILTERMODE, 1) &&
           VerifyField<int8_t>(verifier, VT_MIPMAPMODE, 1) &&
           VerifyField<tgfx::fbs::ImageAttribute>(verifier, VT_IMAGE, 4) &&
           verifier.EndTable();
  }
};

struct ImagePatternAttributeBuilder {
  typedef ImagePatternAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(const tgfx::fbs::ShapeStyleCommonAttribute *common_attribute) {
    fbb_.AddStruct(ImagePatternAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_tilemode_x(tgfx::fbs::TileMode tilemode_x) {
    fbb_.AddElement<int8_t>(ImagePatternAttribute::VT_TILEMODE_X, static_cast<int8_t>(tilemode_x), 0);
  }
  void add_tilemode_y(tgfx::fbs::TileMode tilemode_y) {
    fbb_.AddElement<int8_t>(ImagePatternAttribute::VT_TILEMODE_Y, static_cast<int8_t>(tilemode_y), 0);
  }
  void add_filtermode(tgfx::fbs::FilterMode filtermode) {
    fbb_.AddElement<int8_t>(ImagePatternAttribute::VT_FILTERMODE, static_cast<int8_t>(filtermode), 0);
  }
  void add_mipmapmode(tgfx::fbs::MipmapMode mipmapmode) {
    fbb_.AddElement<int8_t>(ImagePatternAttribute::VT_MIPMAPMODE, static_cast<int8_t>(mipmapmode), 0);
  }
  void add_image(const tgfx::fbs::ImageAttribute *image) {
    fbb_.AddStruct(ImagePatternAttribute::VT_IMAGE, image);
  }
  explicit ImagePatternAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImagePatternAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImagePatternAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ImagePatternAttribute> CreateImagePatternAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const tgfx::fbs::ShapeStyleCommonAttribute *common_attribute = nullptr,
    tgfx::fbs::TileMode tilemode_x = tgfx::fbs::TileMode_Clamp,
    tgfx::fbs::TileMode tilemode_y = tgfx::fbs::TileMode_Clamp,
    tgfx::fbs::FilterMode filtermode = tgfx::fbs::FilterMode_Nearest,
    tgfx::fbs::MipmapMode mipmapmode = tgfx::fbs::MipmapMode_None,
    const tgfx::fbs::ImageAttribute *image = nullptr) {
  ImagePatternAttributeBuilder builder_(_fbb);
  builder_.add_image(image);
  builder_.add_common_attribute(common_attribute);
  builder_.add_mipmapmode(mipmapmode);
  builder_.add_filtermode(filtermode);
  builder_.add_tilemode_y(tilemode_y);
  builder_.add_tilemode_x(tilemode_x);
  return builder_.Finish();
}

struct GradientAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GradientAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_TYPE = 6,
    VT_COLORS = 8,
    VT_POSITIONS = 10
  };
  const tgfx::fbs::ShapeStyleCommonAttribute *common_attribute() const {
    return GetStruct<const tgfx::fbs::ShapeStyleCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  tgfx::fbs::GradientType type() const {
    return static_cast<tgfx::fbs::GradientType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<const tgfx::fbs::Color *> *colors() const {
    return GetPointer<const ::flatbuffers::Vector<const tgfx::fbs::Color *> *>(VT_COLORS);
  }
  const ::flatbuffers::Vector<float> *positions() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_POSITIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<tgfx::fbs::ShapeStyleCommonAttribute>(verifier, VT_COMMON_ATTRIBUTE, 4) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_COLORS) &&
           verifier.VerifyVector(colors()) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(positions()) &&
           verifier.EndTable();
  }
};

struct GradientAttributeBuilder {
  typedef GradientAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(const tgfx::fbs::ShapeStyleCommonAttribute *common_attribute) {
    fbb_.AddStruct(GradientAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_type(tgfx::fbs::GradientType type) {
    fbb_.AddElement<int8_t>(GradientAttribute::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_colors(::flatbuffers::Offset<::flatbuffers::Vector<const tgfx::fbs::Color *>> colors) {
    fbb_.AddOffset(GradientAttribute::VT_COLORS, colors);
  }
  void add_positions(::flatbuffers::Offset<::flatbuffers::Vector<float>> positions) {
    fbb_.AddOffset(GradientAttribute::VT_POSITIONS, positions);
  }
  explicit GradientAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GradientAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GradientAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GradientAttribute> CreateGradientAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const tgfx::fbs::ShapeStyleCommonAttribute *common_attribute = nullptr,
    tgfx::fbs::GradientType type = tgfx::fbs::GradientType_None,
    ::flatbuffers::Offset<::flatbuffers::Vector<const tgfx::fbs::Color *>> colors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> positions = 0) {
  GradientAttributeBuilder builder_(_fbb);
  builder_.add_positions(positions);
  builder_.add_colors(colors);
  builder_.add_common_attribute(common_attribute);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GradientAttribute> CreateGradientAttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const tgfx::fbs::ShapeStyleCommonAttribute *common_attribute = nullptr,
    tgfx::fbs::GradientType type = tgfx::fbs::GradientType_None,
    const std::vector<tgfx::fbs::Color> *colors = nullptr,
    const std::vector<float> *positions = nullptr) {
  auto colors__ = colors ? _fbb.CreateVectorOfStructs<tgfx::fbs::Color>(*colors) : 0;
  auto positions__ = positions ? _fbb.CreateVector<float>(*positions) : 0;
  return tgfx::fbs::CreateGradientAttribute(
      _fbb,
      common_attribute,
      type,
      colors__,
      positions__);
}

struct LinearGradientAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LinearGradientAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRADIENT_ATTRIBUTE = 4,
    VT_START_POINT = 6,
    VT_END_POINT = 8
  };
  const tgfx::fbs::GradientAttribute *gradient_attribute() const {
    return GetPointer<const tgfx::fbs::GradientAttribute *>(VT_GRADIENT_ATTRIBUTE);
  }
  const tgfx::fbs::Point *start_point() const {
    return GetStruct<const tgfx::fbs::Point *>(VT_START_POINT);
  }
  const tgfx::fbs::Point *end_point() const {
    return GetStruct<const tgfx::fbs::Point *>(VT_END_POINT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRADIENT_ATTRIBUTE) &&
           verifier.VerifyTable(gradient_attribute()) &&
           VerifyField<tgfx::fbs::Point>(verifier, VT_START_POINT, 4) &&
           VerifyField<tgfx::fbs::Point>(verifier, VT_END_POINT, 4) &&
           verifier.EndTable();
  }
};

struct LinearGradientAttributeBuilder {
  typedef LinearGradientAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gradient_attribute(::flatbuffers::Offset<tgfx::fbs::GradientAttribute> gradient_attribute) {
    fbb_.AddOffset(LinearGradientAttribute::VT_GRADIENT_ATTRIBUTE, gradient_attribute);
  }
  void add_start_point(const tgfx::fbs::Point *start_point) {
    fbb_.AddStruct(LinearGradientAttribute::VT_START_POINT, start_point);
  }
  void add_end_point(const tgfx::fbs::Point *end_point) {
    fbb_.AddStruct(LinearGradientAttribute::VT_END_POINT, end_point);
  }
  explicit LinearGradientAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LinearGradientAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LinearGradientAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LinearGradientAttribute> CreateLinearGradientAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tgfx::fbs::GradientAttribute> gradient_attribute = 0,
    const tgfx::fbs::Point *start_point = nullptr,
    const tgfx::fbs::Point *end_point = nullptr) {
  LinearGradientAttributeBuilder builder_(_fbb);
  builder_.add_end_point(end_point);
  builder_.add_start_point(start_point);
  builder_.add_gradient_attribute(gradient_attribute);
  return builder_.Finish();
}

struct RadialGradientAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RadialGradientAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRADIENT_ATTRIBUTE = 4,
    VT_CENTER = 6,
    VT_RADIUS = 8
  };
  const tgfx::fbs::GradientAttribute *gradient_attribute() const {
    return GetPointer<const tgfx::fbs::GradientAttribute *>(VT_GRADIENT_ATTRIBUTE);
  }
  const tgfx::fbs::Point *center() const {
    return GetStruct<const tgfx::fbs::Point *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRADIENT_ATTRIBUTE) &&
           verifier.VerifyTable(gradient_attribute()) &&
           VerifyField<tgfx::fbs::Point>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           verifier.EndTable();
  }
};

struct RadialGradientAttributeBuilder {
  typedef RadialGradientAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gradient_attribute(::flatbuffers::Offset<tgfx::fbs::GradientAttribute> gradient_attribute) {
    fbb_.AddOffset(RadialGradientAttribute::VT_GRADIENT_ATTRIBUTE, gradient_attribute);
  }
  void add_center(const tgfx::fbs::Point *center) {
    fbb_.AddStruct(RadialGradientAttribute::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(RadialGradientAttribute::VT_RADIUS, radius, 0.0f);
  }
  explicit RadialGradientAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RadialGradientAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RadialGradientAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RadialGradientAttribute> CreateRadialGradientAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tgfx::fbs::GradientAttribute> gradient_attribute = 0,
    const tgfx::fbs::Point *center = nullptr,
    float radius = 0.0f) {
  RadialGradientAttributeBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add_gradient_attribute(gradient_attribute);
  return builder_.Finish();
}

struct ConicGradientAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConicGradientAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRADIENT_ATTRIBUTE = 4,
    VT_CENTER = 6,
    VT_START_ANGLE = 8,
    VT_END_ANGLE = 10
  };
  const tgfx::fbs::GradientAttribute *gradient_attribute() const {
    return GetPointer<const tgfx::fbs::GradientAttribute *>(VT_GRADIENT_ATTRIBUTE);
  }
  const tgfx::fbs::Point *center() const {
    return GetStruct<const tgfx::fbs::Point *>(VT_CENTER);
  }
  float start_angle() const {
    return GetField<float>(VT_START_ANGLE, 0.0f);
  }
  float end_angle() const {
    return GetField<float>(VT_END_ANGLE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRADIENT_ATTRIBUTE) &&
           verifier.VerifyTable(gradient_attribute()) &&
           VerifyField<tgfx::fbs::Point>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_START_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_END_ANGLE, 4) &&
           verifier.EndTable();
  }
};

struct ConicGradientAttributeBuilder {
  typedef ConicGradientAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gradient_attribute(::flatbuffers::Offset<tgfx::fbs::GradientAttribute> gradient_attribute) {
    fbb_.AddOffset(ConicGradientAttribute::VT_GRADIENT_ATTRIBUTE, gradient_attribute);
  }
  void add_center(const tgfx::fbs::Point *center) {
    fbb_.AddStruct(ConicGradientAttribute::VT_CENTER, center);
  }
  void add_start_angle(float start_angle) {
    fbb_.AddElement<float>(ConicGradientAttribute::VT_START_ANGLE, start_angle, 0.0f);
  }
  void add_end_angle(float end_angle) {
    fbb_.AddElement<float>(ConicGradientAttribute::VT_END_ANGLE, end_angle, 0.0f);
  }
  explicit ConicGradientAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConicGradientAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConicGradientAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConicGradientAttribute> CreateConicGradientAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tgfx::fbs::GradientAttribute> gradient_attribute = 0,
    const tgfx::fbs::Point *center = nullptr,
    float start_angle = 0.0f,
    float end_angle = 0.0f) {
  ConicGradientAttributeBuilder builder_(_fbb);
  builder_.add_end_angle(end_angle);
  builder_.add_start_angle(start_angle);
  builder_.add_center(center);
  builder_.add_gradient_attribute(gradient_attribute);
  return builder_.Finish();
}

struct DiamondGradientAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DiamondGradientAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRADIENT_ATTRIBUTE = 4,
    VT_CENTER = 6,
    VT_HALF_DIAGONAL = 8
  };
  const tgfx::fbs::GradientAttribute *gradient_attribute() const {
    return GetPointer<const tgfx::fbs::GradientAttribute *>(VT_GRADIENT_ATTRIBUTE);
  }
  const tgfx::fbs::Point *center() const {
    return GetStruct<const tgfx::fbs::Point *>(VT_CENTER);
  }
  float half_diagonal() const {
    return GetField<float>(VT_HALF_DIAGONAL, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRADIENT_ATTRIBUTE) &&
           verifier.VerifyTable(gradient_attribute()) &&
           VerifyField<tgfx::fbs::Point>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_HALF_DIAGONAL, 4) &&
           verifier.EndTable();
  }
};

struct DiamondGradientAttributeBuilder {
  typedef DiamondGradientAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gradient_attribute(::flatbuffers::Offset<tgfx::fbs::GradientAttribute> gradient_attribute) {
    fbb_.AddOffset(DiamondGradientAttribute::VT_GRADIENT_ATTRIBUTE, gradient_attribute);
  }
  void add_center(const tgfx::fbs::Point *center) {
    fbb_.AddStruct(DiamondGradientAttribute::VT_CENTER, center);
  }
  void add_half_diagonal(float half_diagonal) {
    fbb_.AddElement<float>(DiamondGradientAttribute::VT_HALF_DIAGONAL, half_diagonal, 0.0f);
  }
  explicit DiamondGradientAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DiamondGradientAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DiamondGradientAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DiamondGradientAttribute> CreateDiamondGradientAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tgfx::fbs::GradientAttribute> gradient_attribute = 0,
    const tgfx::fbs::Point *center = nullptr,
    float half_diagonal = 0.0f) {
  DiamondGradientAttributeBuilder builder_(_fbb);
  builder_.add_half_diagonal(half_diagonal);
  builder_.add_center(center);
  builder_.add_gradient_attribute(gradient_attribute);
  return builder_.Finish();
}

struct ShapeStyle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShapeStyleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPESTYLE_TYPE = 4,
    VT_SHAPESTYLE_BODY_TYPE = 6,
    VT_SHAPESTYLE_BODY = 8
  };
  tgfx::fbs::ShapeStyleType shapestyle_type() const {
    return static_cast<tgfx::fbs::ShapeStyleType>(GetField<int8_t>(VT_SHAPESTYLE_TYPE, 0));
  }
  tgfx::fbs::ShapeStyleAttribute shapestyle_body_type() const {
    return static_cast<tgfx::fbs::ShapeStyleAttribute>(GetField<uint8_t>(VT_SHAPESTYLE_BODY_TYPE, 0));
  }
  const void *shapestyle_body() const {
    return GetPointer<const void *>(VT_SHAPESTYLE_BODY);
  }
  template<typename T> const T *shapestyle_body_as() const;
  const tgfx::fbs::LinearGradientAttribute *shapestyle_body_as_LinearGradientAttribute() const {
    return shapestyle_body_type() == tgfx::fbs::ShapeStyleAttribute_LinearGradientAttribute ? static_cast<const tgfx::fbs::LinearGradientAttribute *>(shapestyle_body()) : nullptr;
  }
  const tgfx::fbs::RadialGradientAttribute *shapestyle_body_as_RadialGradientAttribute() const {
    return shapestyle_body_type() == tgfx::fbs::ShapeStyleAttribute_RadialGradientAttribute ? static_cast<const tgfx::fbs::RadialGradientAttribute *>(shapestyle_body()) : nullptr;
  }
  const tgfx::fbs::ConicGradientAttribute *shapestyle_body_as_ConicGradientAttribute() const {
    return shapestyle_body_type() == tgfx::fbs::ShapeStyleAttribute_ConicGradientAttribute ? static_cast<const tgfx::fbs::ConicGradientAttribute *>(shapestyle_body()) : nullptr;
  }
  const tgfx::fbs::DiamondGradientAttribute *shapestyle_body_as_DiamondGradientAttribute() const {
    return shapestyle_body_type() == tgfx::fbs::ShapeStyleAttribute_DiamondGradientAttribute ? static_cast<const tgfx::fbs::DiamondGradientAttribute *>(shapestyle_body()) : nullptr;
  }
  const tgfx::fbs::ImagePatternAttribute *shapestyle_body_as_ImagePatternAttribute() const {
    return shapestyle_body_type() == tgfx::fbs::ShapeStyleAttribute_ImagePatternAttribute ? static_cast<const tgfx::fbs::ImagePatternAttribute *>(shapestyle_body()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SHAPESTYLE_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SHAPESTYLE_BODY_TYPE, 1) &&
           VerifyOffset(verifier, VT_SHAPESTYLE_BODY) &&
           VerifyShapeStyleAttribute(verifier, shapestyle_body(), shapestyle_body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const tgfx::fbs::LinearGradientAttribute *ShapeStyle::shapestyle_body_as<tgfx::fbs::LinearGradientAttribute>() const {
  return shapestyle_body_as_LinearGradientAttribute();
}

template<> inline const tgfx::fbs::RadialGradientAttribute *ShapeStyle::shapestyle_body_as<tgfx::fbs::RadialGradientAttribute>() const {
  return shapestyle_body_as_RadialGradientAttribute();
}

template<> inline const tgfx::fbs::ConicGradientAttribute *ShapeStyle::shapestyle_body_as<tgfx::fbs::ConicGradientAttribute>() const {
  return shapestyle_body_as_ConicGradientAttribute();
}

template<> inline const tgfx::fbs::DiamondGradientAttribute *ShapeStyle::shapestyle_body_as<tgfx::fbs::DiamondGradientAttribute>() const {
  return shapestyle_body_as_DiamondGradientAttribute();
}

template<> inline const tgfx::fbs::ImagePatternAttribute *ShapeStyle::shapestyle_body_as<tgfx::fbs::ImagePatternAttribute>() const {
  return shapestyle_body_as_ImagePatternAttribute();
}

struct ShapeStyleBuilder {
  typedef ShapeStyle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shapestyle_type(tgfx::fbs::ShapeStyleType shapestyle_type) {
    fbb_.AddElement<int8_t>(ShapeStyle::VT_SHAPESTYLE_TYPE, static_cast<int8_t>(shapestyle_type), 0);
  }
  void add_shapestyle_body_type(tgfx::fbs::ShapeStyleAttribute shapestyle_body_type) {
    fbb_.AddElement<uint8_t>(ShapeStyle::VT_SHAPESTYLE_BODY_TYPE, static_cast<uint8_t>(shapestyle_body_type), 0);
  }
  void add_shapestyle_body(::flatbuffers::Offset<void> shapestyle_body) {
    fbb_.AddOffset(ShapeStyle::VT_SHAPESTYLE_BODY, shapestyle_body);
  }
  explicit ShapeStyleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShapeStyle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShapeStyle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShapeStyle> CreateShapeStyle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tgfx::fbs::ShapeStyleType shapestyle_type = tgfx::fbs::ShapeStyleType_LinearGradient,
    tgfx::fbs::ShapeStyleAttribute shapestyle_body_type = tgfx::fbs::ShapeStyleAttribute_NONE,
    ::flatbuffers::Offset<void> shapestyle_body = 0) {
  ShapeStyleBuilder builder_(_fbb);
  builder_.add_shapestyle_body(shapestyle_body);
  builder_.add_shapestyle_body_type(shapestyle_body_type);
  builder_.add_shapestyle_type(shapestyle_type);
  return builder_.Finish();
}

struct ShapeLayerAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShapeLayerAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_PATH_FILL_TYPE = 6,
    VT_PATH_IS_LINE = 8,
    VT_PATH_IS_RECT = 10,
    VT_PATH_IS_OVAL = 12,
    VT_PATH_IS_EMPTY = 14,
    VT_PATH_BOUNDS = 16,
    VT_PATH_POINT_COUNT = 18,
    VT_PATH_VERBS_COUNT = 20,
    VT_SHAPE_STYLES_ATTRIBUTE = 22
  };
  const tgfx::fbs::LayerCommonAttribute *common_attribute() const {
    return GetPointer<const tgfx::fbs::LayerCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  tgfx::fbs::PathFillType path_fill_type() const {
    return static_cast<tgfx::fbs::PathFillType>(GetField<int8_t>(VT_PATH_FILL_TYPE, 0));
  }
  bool path_is_line() const {
    return GetField<uint8_t>(VT_PATH_IS_LINE, 0) != 0;
  }
  bool path_is_rect() const {
    return GetField<uint8_t>(VT_PATH_IS_RECT, 0) != 0;
  }
  bool path_is_oval() const {
    return GetField<uint8_t>(VT_PATH_IS_OVAL, 0) != 0;
  }
  bool path_is_empty() const {
    return GetField<uint8_t>(VT_PATH_IS_EMPTY, 0) != 0;
  }
  const tgfx::fbs::Rect *path_bounds() const {
    return GetStruct<const tgfx::fbs::Rect *>(VT_PATH_BOUNDS);
  }
  int32_t path_point_count() const {
    return GetField<int32_t>(VT_PATH_POINT_COUNT, 0);
  }
  int32_t path_verbs_count() const {
    return GetField<int32_t>(VT_PATH_VERBS_COUNT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::ShapeStyle>> *shape_styles_attribute() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::ShapeStyle>> *>(VT_SHAPE_STYLES_ATTRIBUTE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON_ATTRIBUTE) &&
           verifier.VerifyTable(common_attribute()) &&
           VerifyField<int8_t>(verifier, VT_PATH_FILL_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PATH_IS_LINE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PATH_IS_RECT, 1) &&
           VerifyField<uint8_t>(verifier, VT_PATH_IS_OVAL, 1) &&
           VerifyField<uint8_t>(verifier, VT_PATH_IS_EMPTY, 1) &&
           VerifyField<tgfx::fbs::Rect>(verifier, VT_PATH_BOUNDS, 4) &&
           VerifyField<int32_t>(verifier, VT_PATH_POINT_COUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_PATH_VERBS_COUNT, 4) &&
           VerifyOffset(verifier, VT_SHAPE_STYLES_ATTRIBUTE) &&
           verifier.VerifyVector(shape_styles_attribute()) &&
           verifier.VerifyVectorOfTables(shape_styles_attribute()) &&
           verifier.EndTable();
  }
};

struct ShapeLayerAttributeBuilder {
  typedef ShapeLayerAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(::flatbuffers::Offset<tgfx::fbs::LayerCommonAttribute> common_attribute) {
    fbb_.AddOffset(ShapeLayerAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_path_fill_type(tgfx::fbs::PathFillType path_fill_type) {
    fbb_.AddElement<int8_t>(ShapeLayerAttribute::VT_PATH_FILL_TYPE, static_cast<int8_t>(path_fill_type), 0);
  }
  void add_path_is_line(bool path_is_line) {
    fbb_.AddElement<uint8_t>(ShapeLayerAttribute::VT_PATH_IS_LINE, static_cast<uint8_t>(path_is_line), 0);
  }
  void add_path_is_rect(bool path_is_rect) {
    fbb_.AddElement<uint8_t>(ShapeLayerAttribute::VT_PATH_IS_RECT, static_cast<uint8_t>(path_is_rect), 0);
  }
  void add_path_is_oval(bool path_is_oval) {
    fbb_.AddElement<uint8_t>(ShapeLayerAttribute::VT_PATH_IS_OVAL, static_cast<uint8_t>(path_is_oval), 0);
  }
  void add_path_is_empty(bool path_is_empty) {
    fbb_.AddElement<uint8_t>(ShapeLayerAttribute::VT_PATH_IS_EMPTY, static_cast<uint8_t>(path_is_empty), 0);
  }
  void add_path_bounds(const tgfx::fbs::Rect *path_bounds) {
    fbb_.AddStruct(ShapeLayerAttribute::VT_PATH_BOUNDS, path_bounds);
  }
  void add_path_point_count(int32_t path_point_count) {
    fbb_.AddElement<int32_t>(ShapeLayerAttribute::VT_PATH_POINT_COUNT, path_point_count, 0);
  }
  void add_path_verbs_count(int32_t path_verbs_count) {
    fbb_.AddElement<int32_t>(ShapeLayerAttribute::VT_PATH_VERBS_COUNT, path_verbs_count, 0);
  }
  void add_shape_styles_attribute(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::ShapeStyle>>> shape_styles_attribute) {
    fbb_.AddOffset(ShapeLayerAttribute::VT_SHAPE_STYLES_ATTRIBUTE, shape_styles_attribute);
  }
  explicit ShapeLayerAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShapeLayerAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShapeLayerAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShapeLayerAttribute> CreateShapeLayerAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tgfx::fbs::LayerCommonAttribute> common_attribute = 0,
    tgfx::fbs::PathFillType path_fill_type = tgfx::fbs::PathFillType_Winding,
    bool path_is_line = false,
    bool path_is_rect = false,
    bool path_is_oval = false,
    bool path_is_empty = false,
    const tgfx::fbs::Rect *path_bounds = nullptr,
    int32_t path_point_count = 0,
    int32_t path_verbs_count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::ShapeStyle>>> shape_styles_attribute = 0) {
  ShapeLayerAttributeBuilder builder_(_fbb);
  builder_.add_shape_styles_attribute(shape_styles_attribute);
  builder_.add_path_verbs_count(path_verbs_count);
  builder_.add_path_point_count(path_point_count);
  builder_.add_path_bounds(path_bounds);
  builder_.add_common_attribute(common_attribute);
  builder_.add_path_is_empty(path_is_empty);
  builder_.add_path_is_oval(path_is_oval);
  builder_.add_path_is_rect(path_is_rect);
  builder_.add_path_is_line(path_is_line);
  builder_.add_path_fill_type(path_fill_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ShapeLayerAttribute> CreateShapeLayerAttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tgfx::fbs::LayerCommonAttribute> common_attribute = 0,
    tgfx::fbs::PathFillType path_fill_type = tgfx::fbs::PathFillType_Winding,
    bool path_is_line = false,
    bool path_is_rect = false,
    bool path_is_oval = false,
    bool path_is_empty = false,
    const tgfx::fbs::Rect *path_bounds = nullptr,
    int32_t path_point_count = 0,
    int32_t path_verbs_count = 0,
    const std::vector<::flatbuffers::Offset<tgfx::fbs::ShapeStyle>> *shape_styles_attribute = nullptr) {
  auto shape_styles_attribute__ = shape_styles_attribute ? _fbb.CreateVector<::flatbuffers::Offset<tgfx::fbs::ShapeStyle>>(*shape_styles_attribute) : 0;
  return tgfx::fbs::CreateShapeLayerAttribute(
      _fbb,
      common_attribute,
      path_fill_type,
      path_is_line,
      path_is_rect,
      path_is_oval,
      path_is_empty,
      path_bounds,
      path_point_count,
      path_verbs_count,
      shape_styles_attribute__);
}

struct SolidLayerAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SolidLayerAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_WIDTH = 6,
    VT_HEIGHT = 8,
    VT_SOLID_RADIUS_X = 10,
    VT_SOLID_RADIUS_Y = 12,
    VT_SOLID_COLOR = 14
  };
  const tgfx::fbs::LayerCommonAttribute *common_attribute() const {
    return GetPointer<const tgfx::fbs::LayerCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  float solid_radius_x() const {
    return GetField<float>(VT_SOLID_RADIUS_X, 0.0f);
  }
  float solid_radius_y() const {
    return GetField<float>(VT_SOLID_RADIUS_Y, 0.0f);
  }
  const tgfx::fbs::Color *solid_color() const {
    return GetStruct<const tgfx::fbs::Color *>(VT_SOLID_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON_ATTRIBUTE) &&
           verifier.VerifyTable(common_attribute()) &&
           VerifyField<float>(verifier, VT_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_HEIGHT, 4) &&
           VerifyField<float>(verifier, VT_SOLID_RADIUS_X, 4) &&
           VerifyField<float>(verifier, VT_SOLID_RADIUS_Y, 4) &&
           VerifyField<tgfx::fbs::Color>(verifier, VT_SOLID_COLOR, 4) &&
           verifier.EndTable();
  }
};

struct SolidLayerAttributeBuilder {
  typedef SolidLayerAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(::flatbuffers::Offset<tgfx::fbs::LayerCommonAttribute> common_attribute) {
    fbb_.AddOffset(SolidLayerAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(SolidLayerAttribute::VT_WIDTH, width, 0.0f);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(SolidLayerAttribute::VT_HEIGHT, height, 0.0f);
  }
  void add_solid_radius_x(float solid_radius_x) {
    fbb_.AddElement<float>(SolidLayerAttribute::VT_SOLID_RADIUS_X, solid_radius_x, 0.0f);
  }
  void add_solid_radius_y(float solid_radius_y) {
    fbb_.AddElement<float>(SolidLayerAttribute::VT_SOLID_RADIUS_Y, solid_radius_y, 0.0f);
  }
  void add_solid_color(const tgfx::fbs::Color *solid_color) {
    fbb_.AddStruct(SolidLayerAttribute::VT_SOLID_COLOR, solid_color);
  }
  explicit SolidLayerAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SolidLayerAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SolidLayerAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SolidLayerAttribute> CreateSolidLayerAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tgfx::fbs::LayerCommonAttribute> common_attribute = 0,
    float width = 0.0f,
    float height = 0.0f,
    float solid_radius_x = 0.0f,
    float solid_radius_y = 0.0f,
    const tgfx::fbs::Color *solid_color = nullptr) {
  SolidLayerAttributeBuilder builder_(_fbb);
  builder_.add_solid_color(solid_color);
  builder_.add_solid_radius_y(solid_radius_y);
  builder_.add_solid_radius_x(solid_radius_x);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_common_attribute(common_attribute);
  return builder_.Finish();
}

struct TypeFace FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TypeFaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNIQUE_ID = 4,
    VT_FONT_FAMILY = 6,
    VT_FONT_STYLE = 8,
    VT_GLYPHS_COUNT = 10,
    VT_UNITS_PER_EM = 12,
    VT_HAS_COLOR = 14,
    VT_HAS_OUTLINES = 16
  };
  uint32_t unique_id() const {
    return GetField<uint32_t>(VT_UNIQUE_ID, 0);
  }
  const ::flatbuffers::String *font_family() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FONT_FAMILY);
  }
  const ::flatbuffers::String *font_style() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FONT_STYLE);
  }
  uint32_t glyphs_count() const {
    return GetField<uint32_t>(VT_GLYPHS_COUNT, 0);
  }
  int32_t units_per_em() const {
    return GetField<int32_t>(VT_UNITS_PER_EM, 0);
  }
  bool has_color() const {
    return GetField<uint8_t>(VT_HAS_COLOR, 0) != 0;
  }
  bool has_outlines() const {
    return GetField<uint8_t>(VT_HAS_OUTLINES, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UNIQUE_ID, 4) &&
           VerifyOffset(verifier, VT_FONT_FAMILY) &&
           verifier.VerifyString(font_family()) &&
           VerifyOffset(verifier, VT_FONT_STYLE) &&
           verifier.VerifyString(font_style()) &&
           VerifyField<uint32_t>(verifier, VT_GLYPHS_COUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_UNITS_PER_EM, 4) &&
           VerifyField<uint8_t>(verifier, VT_HAS_COLOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_HAS_OUTLINES, 1) &&
           verifier.EndTable();
  }
};

struct TypeFaceBuilder {
  typedef TypeFace Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_unique_id(uint32_t unique_id) {
    fbb_.AddElement<uint32_t>(TypeFace::VT_UNIQUE_ID, unique_id, 0);
  }
  void add_font_family(::flatbuffers::Offset<::flatbuffers::String> font_family) {
    fbb_.AddOffset(TypeFace::VT_FONT_FAMILY, font_family);
  }
  void add_font_style(::flatbuffers::Offset<::flatbuffers::String> font_style) {
    fbb_.AddOffset(TypeFace::VT_FONT_STYLE, font_style);
  }
  void add_glyphs_count(uint32_t glyphs_count) {
    fbb_.AddElement<uint32_t>(TypeFace::VT_GLYPHS_COUNT, glyphs_count, 0);
  }
  void add_units_per_em(int32_t units_per_em) {
    fbb_.AddElement<int32_t>(TypeFace::VT_UNITS_PER_EM, units_per_em, 0);
  }
  void add_has_color(bool has_color) {
    fbb_.AddElement<uint8_t>(TypeFace::VT_HAS_COLOR, static_cast<uint8_t>(has_color), 0);
  }
  void add_has_outlines(bool has_outlines) {
    fbb_.AddElement<uint8_t>(TypeFace::VT_HAS_OUTLINES, static_cast<uint8_t>(has_outlines), 0);
  }
  explicit TypeFaceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TypeFace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TypeFace>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TypeFace> CreateTypeFace(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t unique_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> font_family = 0,
    ::flatbuffers::Offset<::flatbuffers::String> font_style = 0,
    uint32_t glyphs_count = 0,
    int32_t units_per_em = 0,
    bool has_color = false,
    bool has_outlines = false) {
  TypeFaceBuilder builder_(_fbb);
  builder_.add_units_per_em(units_per_em);
  builder_.add_glyphs_count(glyphs_count);
  builder_.add_font_style(font_style);
  builder_.add_font_family(font_family);
  builder_.add_unique_id(unique_id);
  builder_.add_has_outlines(has_outlines);
  builder_.add_has_color(has_color);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TypeFace> CreateTypeFaceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t unique_id = 0,
    const char *font_family = nullptr,
    const char *font_style = nullptr,
    uint32_t glyphs_count = 0,
    int32_t units_per_em = 0,
    bool has_color = false,
    bool has_outlines = false) {
  auto font_family__ = font_family ? _fbb.CreateString(font_family) : 0;
  auto font_style__ = font_style ? _fbb.CreateString(font_style) : 0;
  return tgfx::fbs::CreateTypeFace(
      _fbb,
      unique_id,
      font_family__,
      font_style__,
      glyphs_count,
      units_per_em,
      has_color,
      has_outlines);
}

struct Font FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FontBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HAS_COLOR = 4,
    VT_HAS_OUTLINES = 6,
    VT_SIZE = 8,
    VT_IS_FAUX_BOLD = 10,
    VT_IS_FAUX_TTALIC = 12,
    VT_TYPE_FACE = 14
  };
  bool has_color() const {
    return GetField<uint8_t>(VT_HAS_COLOR, 0) != 0;
  }
  bool has_outlines() const {
    return GetField<uint8_t>(VT_HAS_OUTLINES, 0) != 0;
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  bool is_faux_bold() const {
    return GetField<uint8_t>(VT_IS_FAUX_BOLD, 0) != 0;
  }
  bool is_faux_ttalic() const {
    return GetField<uint8_t>(VT_IS_FAUX_TTALIC, 0) != 0;
  }
  const tgfx::fbs::TypeFace *type_face() const {
    return GetPointer<const tgfx::fbs::TypeFace *>(VT_TYPE_FACE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HAS_COLOR, 1) &&
           VerifyField<uint8_t>(verifier, VT_HAS_OUTLINES, 1) &&
           VerifyField<float>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_FAUX_BOLD, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_FAUX_TTALIC, 1) &&
           VerifyOffset(verifier, VT_TYPE_FACE) &&
           verifier.VerifyTable(type_face()) &&
           verifier.EndTable();
  }
};

struct FontBuilder {
  typedef Font Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_has_color(bool has_color) {
    fbb_.AddElement<uint8_t>(Font::VT_HAS_COLOR, static_cast<uint8_t>(has_color), 0);
  }
  void add_has_outlines(bool has_outlines) {
    fbb_.AddElement<uint8_t>(Font::VT_HAS_OUTLINES, static_cast<uint8_t>(has_outlines), 0);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(Font::VT_SIZE, size, 0.0f);
  }
  void add_is_faux_bold(bool is_faux_bold) {
    fbb_.AddElement<uint8_t>(Font::VT_IS_FAUX_BOLD, static_cast<uint8_t>(is_faux_bold), 0);
  }
  void add_is_faux_ttalic(bool is_faux_ttalic) {
    fbb_.AddElement<uint8_t>(Font::VT_IS_FAUX_TTALIC, static_cast<uint8_t>(is_faux_ttalic), 0);
  }
  void add_type_face(::flatbuffers::Offset<tgfx::fbs::TypeFace> type_face) {
    fbb_.AddOffset(Font::VT_TYPE_FACE, type_face);
  }
  explicit FontBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Font> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Font>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Font> CreateFont(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool has_color = false,
    bool has_outlines = false,
    float size = 0.0f,
    bool is_faux_bold = false,
    bool is_faux_ttalic = false,
    ::flatbuffers::Offset<tgfx::fbs::TypeFace> type_face = 0) {
  FontBuilder builder_(_fbb);
  builder_.add_type_face(type_face);
  builder_.add_size(size);
  builder_.add_is_faux_ttalic(is_faux_ttalic);
  builder_.add_is_faux_bold(is_faux_bold);
  builder_.add_has_outlines(has_outlines);
  builder_.add_has_color(has_color);
  return builder_.Finish();
}

struct TextLayerAttribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextLayerAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON_ATTRIBUTE = 4,
    VT_TEXT_STRING = 6,
    VT_TEXT_COLOR = 8,
    VT_TEXT_FONT = 10,
    VT_FONT_METRICS = 12,
    VT_TEXT_WIDTH = 14,
    VT_TEXT_HEIGHT = 16,
    VT_TEXT_ALIGN = 18,
    VT_TEXT_AUTO_WRAP = 20
  };
  const tgfx::fbs::LayerCommonAttribute *common_attribute() const {
    return GetPointer<const tgfx::fbs::LayerCommonAttribute *>(VT_COMMON_ATTRIBUTE);
  }
  const ::flatbuffers::String *text_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT_STRING);
  }
  const tgfx::fbs::Color *text_color() const {
    return GetStruct<const tgfx::fbs::Color *>(VT_TEXT_COLOR);
  }
  const tgfx::fbs::Font *text_font() const {
    return GetPointer<const tgfx::fbs::Font *>(VT_TEXT_FONT);
  }
  const tgfx::fbs::FontMetrics *font_metrics() const {
    return GetStruct<const tgfx::fbs::FontMetrics *>(VT_FONT_METRICS);
  }
  float text_width() const {
    return GetField<float>(VT_TEXT_WIDTH, 0.0f);
  }
  float text_height() const {
    return GetField<float>(VT_TEXT_HEIGHT, 0.0f);
  }
  tgfx::fbs::TextAlign text_align() const {
    return static_cast<tgfx::fbs::TextAlign>(GetField<int8_t>(VT_TEXT_ALIGN, 0));
  }
  bool text_auto_wrap() const {
    return GetField<uint8_t>(VT_TEXT_AUTO_WRAP, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON_ATTRIBUTE) &&
           verifier.VerifyTable(common_attribute()) &&
           VerifyOffset(verifier, VT_TEXT_STRING) &&
           verifier.VerifyString(text_string()) &&
           VerifyField<tgfx::fbs::Color>(verifier, VT_TEXT_COLOR, 4) &&
           VerifyOffset(verifier, VT_TEXT_FONT) &&
           verifier.VerifyTable(text_font()) &&
           VerifyField<tgfx::fbs::FontMetrics>(verifier, VT_FONT_METRICS, 4) &&
           VerifyField<float>(verifier, VT_TEXT_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_TEXT_HEIGHT, 4) &&
           VerifyField<int8_t>(verifier, VT_TEXT_ALIGN, 1) &&
           VerifyField<uint8_t>(verifier, VT_TEXT_AUTO_WRAP, 1) &&
           verifier.EndTable();
  }
};

struct TextLayerAttributeBuilder {
  typedef TextLayerAttribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common_attribute(::flatbuffers::Offset<tgfx::fbs::LayerCommonAttribute> common_attribute) {
    fbb_.AddOffset(TextLayerAttribute::VT_COMMON_ATTRIBUTE, common_attribute);
  }
  void add_text_string(::flatbuffers::Offset<::flatbuffers::String> text_string) {
    fbb_.AddOffset(TextLayerAttribute::VT_TEXT_STRING, text_string);
  }
  void add_text_color(const tgfx::fbs::Color *text_color) {
    fbb_.AddStruct(TextLayerAttribute::VT_TEXT_COLOR, text_color);
  }
  void add_text_font(::flatbuffers::Offset<tgfx::fbs::Font> text_font) {
    fbb_.AddOffset(TextLayerAttribute::VT_TEXT_FONT, text_font);
  }
  void add_font_metrics(const tgfx::fbs::FontMetrics *font_metrics) {
    fbb_.AddStruct(TextLayerAttribute::VT_FONT_METRICS, font_metrics);
  }
  void add_text_width(float text_width) {
    fbb_.AddElement<float>(TextLayerAttribute::VT_TEXT_WIDTH, text_width, 0.0f);
  }
  void add_text_height(float text_height) {
    fbb_.AddElement<float>(TextLayerAttribute::VT_TEXT_HEIGHT, text_height, 0.0f);
  }
  void add_text_align(tgfx::fbs::TextAlign text_align) {
    fbb_.AddElement<int8_t>(TextLayerAttribute::VT_TEXT_ALIGN, static_cast<int8_t>(text_align), 0);
  }
  void add_text_auto_wrap(bool text_auto_wrap) {
    fbb_.AddElement<uint8_t>(TextLayerAttribute::VT_TEXT_AUTO_WRAP, static_cast<uint8_t>(text_auto_wrap), 0);
  }
  explicit TextLayerAttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextLayerAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextLayerAttribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextLayerAttribute> CreateTextLayerAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tgfx::fbs::LayerCommonAttribute> common_attribute = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text_string = 0,
    const tgfx::fbs::Color *text_color = nullptr,
    ::flatbuffers::Offset<tgfx::fbs::Font> text_font = 0,
    const tgfx::fbs::FontMetrics *font_metrics = nullptr,
    float text_width = 0.0f,
    float text_height = 0.0f,
    tgfx::fbs::TextAlign text_align = tgfx::fbs::TextAlign_Left,
    bool text_auto_wrap = false) {
  TextLayerAttributeBuilder builder_(_fbb);
  builder_.add_text_height(text_height);
  builder_.add_text_width(text_width);
  builder_.add_font_metrics(font_metrics);
  builder_.add_text_font(text_font);
  builder_.add_text_color(text_color);
  builder_.add_text_string(text_string);
  builder_.add_common_attribute(common_attribute);
  builder_.add_text_auto_wrap(text_auto_wrap);
  builder_.add_text_align(text_align);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TextLayerAttribute> CreateTextLayerAttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<tgfx::fbs::LayerCommonAttribute> common_attribute = 0,
    const char *text_string = nullptr,
    const tgfx::fbs::Color *text_color = nullptr,
    ::flatbuffers::Offset<tgfx::fbs::Font> text_font = 0,
    const tgfx::fbs::FontMetrics *font_metrics = nullptr,
    float text_width = 0.0f,
    float text_height = 0.0f,
    tgfx::fbs::TextAlign text_align = tgfx::fbs::TextAlign_Left,
    bool text_auto_wrap = false) {
  auto text_string__ = text_string ? _fbb.CreateString(text_string) : 0;
  return tgfx::fbs::CreateTextLayerAttribute(
      _fbb,
      common_attribute,
      text_string__,
      text_color,
      text_font,
      font_metrics,
      text_width,
      text_height,
      text_align,
      text_auto_wrap);
}

struct Layer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAYER_TYPE = 4,
    VT_LAYER_BODY_TYPE = 6,
    VT_LAYER_BODY = 8
  };
  tgfx::fbs::LayerType layer_type() const {
    return static_cast<tgfx::fbs::LayerType>(GetField<int8_t>(VT_LAYER_TYPE, 0));
  }
  tgfx::fbs::LayerAttribute layer_body_type() const {
    return static_cast<tgfx::fbs::LayerAttribute>(GetField<uint8_t>(VT_LAYER_BODY_TYPE, 0));
  }
  const void *layer_body() const {
    return GetPointer<const void *>(VT_LAYER_BODY);
  }
  template<typename T> const T *layer_body_as() const;
  const tgfx::fbs::LayerCommonAttribute *layer_body_as_LayerCommonAttribute() const {
    return layer_body_type() == tgfx::fbs::LayerAttribute_LayerCommonAttribute ? static_cast<const tgfx::fbs::LayerCommonAttribute *>(layer_body()) : nullptr;
  }
  const tgfx::fbs::ImageLayerAttribute *layer_body_as_ImageLayerAttribute() const {
    return layer_body_type() == tgfx::fbs::LayerAttribute_ImageLayerAttribute ? static_cast<const tgfx::fbs::ImageLayerAttribute *>(layer_body()) : nullptr;
  }
  const tgfx::fbs::ShapeLayerAttribute *layer_body_as_ShapeLayerAttribute() const {
    return layer_body_type() == tgfx::fbs::LayerAttribute_ShapeLayerAttribute ? static_cast<const tgfx::fbs::ShapeLayerAttribute *>(layer_body()) : nullptr;
  }
  const tgfx::fbs::SolidLayerAttribute *layer_body_as_SolidLayerAttribute() const {
    return layer_body_type() == tgfx::fbs::LayerAttribute_SolidLayerAttribute ? static_cast<const tgfx::fbs::SolidLayerAttribute *>(layer_body()) : nullptr;
  }
  const tgfx::fbs::TextLayerAttribute *layer_body_as_TextLayerAttribute() const {
    return layer_body_type() == tgfx::fbs::LayerAttribute_TextLayerAttribute ? static_cast<const tgfx::fbs::TextLayerAttribute *>(layer_body()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LAYER_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_LAYER_BODY_TYPE, 1) &&
           VerifyOffset(verifier, VT_LAYER_BODY) &&
           VerifyLayerAttribute(verifier, layer_body(), layer_body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const tgfx::fbs::LayerCommonAttribute *Layer::layer_body_as<tgfx::fbs::LayerCommonAttribute>() const {
  return layer_body_as_LayerCommonAttribute();
}

template<> inline const tgfx::fbs::ImageLayerAttribute *Layer::layer_body_as<tgfx::fbs::ImageLayerAttribute>() const {
  return layer_body_as_ImageLayerAttribute();
}

template<> inline const tgfx::fbs::ShapeLayerAttribute *Layer::layer_body_as<tgfx::fbs::ShapeLayerAttribute>() const {
  return layer_body_as_ShapeLayerAttribute();
}

template<> inline const tgfx::fbs::SolidLayerAttribute *Layer::layer_body_as<tgfx::fbs::SolidLayerAttribute>() const {
  return layer_body_as_SolidLayerAttribute();
}

template<> inline const tgfx::fbs::TextLayerAttribute *Layer::layer_body_as<tgfx::fbs::TextLayerAttribute>() const {
  return layer_body_as_TextLayerAttribute();
}

struct LayerBuilder {
  typedef Layer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_layer_type(tgfx::fbs::LayerType layer_type) {
    fbb_.AddElement<int8_t>(Layer::VT_LAYER_TYPE, static_cast<int8_t>(layer_type), 0);
  }
  void add_layer_body_type(tgfx::fbs::LayerAttribute layer_body_type) {
    fbb_.AddElement<uint8_t>(Layer::VT_LAYER_BODY_TYPE, static_cast<uint8_t>(layer_body_type), 0);
  }
  void add_layer_body(::flatbuffers::Offset<void> layer_body) {
    fbb_.AddOffset(Layer::VT_LAYER_BODY, layer_body);
  }
  explicit LayerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Layer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Layer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Layer> CreateLayer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tgfx::fbs::LayerType layer_type = tgfx::fbs::LayerType_Layer,
    tgfx::fbs::LayerAttribute layer_body_type = tgfx::fbs::LayerAttribute_NONE,
    ::flatbuffers::Offset<void> layer_body = 0) {
  LayerBuilder builder_(_fbb);
  builder_.add_layer_body(layer_body);
  builder_.add_layer_body_type(layer_body_type);
  builder_.add_layer_type(layer_type);
  return builder_.Finish();
}

struct TreeNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TreeNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_CHILDREN = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::TreeNode>> *children() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::TreeNode>> *>(VT_CHILDREN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
};

struct TreeNodeBuilder {
  typedef TreeNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(TreeNode::VT_NAME, name);
  }
  void add_children(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::TreeNode>>> children) {
    fbb_.AddOffset(TreeNode::VT_CHILDREN, children);
  }
  explicit TreeNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TreeNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TreeNode>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TreeNode> CreateTreeNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<tgfx::fbs::TreeNode>>> children = 0) {
  TreeNodeBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TreeNode> CreateTreeNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<tgfx::fbs::TreeNode>> *children = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto children__ = children ? _fbb.CreateVector<::flatbuffers::Offset<tgfx::fbs::TreeNode>>(*children) : 0;
  return tgfx::fbs::CreateTreeNode(
      _fbb,
      name__,
      children__);
}

struct FinalData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FinalDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  tgfx::fbs::Type type() const {
    return static_cast<tgfx::fbs::Type>(GetField<int8_t>(VT_TYPE, 0));
  }
  tgfx::fbs::Data data_type() const {
    return static_cast<tgfx::fbs::Data>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const tgfx::fbs::Layer *data_as_Layer() const {
    return data_type() == tgfx::fbs::Data_Layer ? static_cast<const tgfx::fbs::Layer *>(data()) : nullptr;
  }
  const tgfx::fbs::TreeNode *data_as_TreeNode() const {
    return data_type() == tgfx::fbs::Data_TreeNode ? static_cast<const tgfx::fbs::TreeNode *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const tgfx::fbs::Layer *FinalData::data_as<tgfx::fbs::Layer>() const {
  return data_as_Layer();
}

template<> inline const tgfx::fbs::TreeNode *FinalData::data_as<tgfx::fbs::TreeNode>() const {
  return data_as_TreeNode();
}

struct FinalDataBuilder {
  typedef FinalData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(tgfx::fbs::Type type) {
    fbb_.AddElement<int8_t>(FinalData::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_data_type(tgfx::fbs::Data data_type) {
    fbb_.AddElement<uint8_t>(FinalData::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(FinalData::VT_DATA, data);
  }
  explicit FinalDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FinalData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FinalData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FinalData> CreateFinalData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    tgfx::fbs::Type type = tgfx::fbs::Type_TreeData,
    tgfx::fbs::Data data_type = tgfx::fbs::Data_NONE,
    ::flatbuffers::Offset<void> data = 0) {
  FinalDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline bool VerifyLayerStyleAttribute(::flatbuffers::Verifier &verifier, const void *obj, LayerStyleAttribute type) {
  switch (type) {
    case LayerStyleAttribute_NONE: {
      return true;
    }
    case LayerStyleAttribute_BackGroundBlurStyleAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::BackGroundBlurStyleAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LayerStyleAttribute_DropShadowStyleAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::DropShadowStyleAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LayerStyleAttribute_InnerShadowStyleAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::InnerShadowStyleAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLayerStyleAttributeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLayerStyleAttribute(
        verifier,  values->Get(i), types->GetEnum<LayerStyleAttribute>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyLayerFilterAttribute(::flatbuffers::Verifier &verifier, const void *obj, LayerFilterAttribute type) {
  switch (type) {
    case LayerFilterAttribute_NONE: {
      return true;
    }
    case LayerFilterAttribute_BlendFilterAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::BlendFilterAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LayerFilterAttribute_BlurFilterAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::BlurFilterAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LayerFilterAttribute_ColorFilterAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::ColorFilterAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LayerFilterAttribute_DropShadowFilterAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::DropShadowFilterAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LayerFilterAttribute_InnerShadowFilterAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::InnerShadowFilterAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLayerFilterAttributeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLayerFilterAttribute(
        verifier,  values->Get(i), types->GetEnum<LayerFilterAttribute>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyShapeStyleAttribute(::flatbuffers::Verifier &verifier, const void *obj, ShapeStyleAttribute type) {
  switch (type) {
    case ShapeStyleAttribute_NONE: {
      return true;
    }
    case ShapeStyleAttribute_LinearGradientAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::LinearGradientAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ShapeStyleAttribute_RadialGradientAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::RadialGradientAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ShapeStyleAttribute_ConicGradientAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::ConicGradientAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ShapeStyleAttribute_DiamondGradientAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::DiamondGradientAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ShapeStyleAttribute_ImagePatternAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::ImagePatternAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyShapeStyleAttributeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyShapeStyleAttribute(
        verifier,  values->Get(i), types->GetEnum<ShapeStyleAttribute>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyLayerAttribute(::flatbuffers::Verifier &verifier, const void *obj, LayerAttribute type) {
  switch (type) {
    case LayerAttribute_NONE: {
      return true;
    }
    case LayerAttribute_LayerCommonAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::LayerCommonAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LayerAttribute_ImageLayerAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::ImageLayerAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LayerAttribute_ShapeLayerAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::ShapeLayerAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LayerAttribute_SolidLayerAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::SolidLayerAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LayerAttribute_TextLayerAttribute: {
      auto ptr = reinterpret_cast<const tgfx::fbs::TextLayerAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLayerAttributeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLayerAttribute(
        verifier,  values->Get(i), types->GetEnum<LayerAttribute>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyData(::flatbuffers::Verifier &verifier, const void *obj, Data type) {
  switch (type) {
    case Data_NONE: {
      return true;
    }
    case Data_Layer: {
      auto ptr = reinterpret_cast<const tgfx::fbs::Layer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_TreeNode: {
      auto ptr = reinterpret_cast<const tgfx::fbs::TreeNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyData(
        verifier,  values->Get(i), types->GetEnum<Data>(i))) {
      return false;
    }
  }
  return true;
}

inline const tgfx::fbs::FinalData *GetFinalData(const void *buf) {
  return ::flatbuffers::GetRoot<tgfx::fbs::FinalData>(buf);
}

inline const tgfx::fbs::FinalData *GetSizePrefixedFinalData(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<tgfx::fbs::FinalData>(buf);
}

inline bool VerifyFinalDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tgfx::fbs::FinalData>(nullptr);
}

inline bool VerifySizePrefixedFinalDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tgfx::fbs::FinalData>(nullptr);
}

inline void FinishFinalDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tgfx::fbs::FinalData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFinalDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<tgfx::fbs::FinalData> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace tgfx

#endif  // FLATBUFFERS_GENERATED_SERIALIZATIONSTRUCTURE_TGFX_FBS_H_
