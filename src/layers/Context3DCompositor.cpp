/////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Tencent is pleased to support the open source community by making tgfx available.
//
//  Copyright (C) 2025 Tencent. All rights reserved.
//
//  Licensed under the BSD 3-Clause License (the "License"); you may not use this file except
//  in compliance with the License. You may obtain a copy of the License at
//
//      https://opensource.org/licenses/BSD-3-Clause
//
//  unless required by applicable law or agreed to in writing, software distributed under the
//  license is distributed on an "as is" basis, without warranties or conditions of any kind,
//  either express or implied. see the license for the specific language governing permissions
//  and limitations under the license.
//
/////////////////////////////////////////////////////////////////////////////////////////////////

#include "Context3DCompositor.h"
#include "core/images/TextureImage.h"
#include "core/utils/MathExtra.h"
#include "gpu/DrawingManager.h"
#include "gpu/ProxyProvider.h"
#include "gpu/RectsVertexProvider.h"
#include "gpu/TPArgs.h"
#include "gpu/ops/Rect3DDrawOp.h"
#include "gpu/processors/TextureEffect.h"

namespace tgfx {

Context3DCompositor::Context3DCompositor(const Context& context, int width, int height)
    : width(width), height(height) {
  // Use MSAA to solve the aliasing issue at the intersection lines of multiple layers.
  targetColorProxy = context.proxyProvider()->createRenderTargetProxy({}, width, height,
                                                                      PixelFormat::RGBA_8888, 4);
  DEBUG_ASSERT(targetColorProxy != nullptr);
  targetDepthStencilProxy = context.proxyProvider()->createRenderTargetProxy(
      {}, width, height, PixelFormat::DEPTH24_STENCIL8, 4);
  DEBUG_ASSERT(targetDepthStencilProxy != nullptr);
}

void Context3DCompositor::drawImage(std::shared_ptr<Image> image, const Matrix3D& matrix, float x,
                                    float y, float alpha) {
  DEBUG_ASSERT(targetColorProxy != nullptr);
  DEBUG_ASSERT(targetDepthStencilProxy != nullptr);
  auto context = targetColorProxy->getContext();
  DEBUG_ASSERT(context != nullptr);

  auto srcW = static_cast<float>(image->width());
  auto srcH = static_cast<float>(image->height());
  // The default transformation anchor is at the top-left origin (0,0) of the image; user-defined
  // anchors are included in the matrix.
  auto srcModelRect = Rect::MakeXYWH(0.f, 0.f, srcW, srcH);
  auto srcProjectRect = matrix.mapRect(srcModelRect);
  // ndcScale and ndcOffset are used to scale and translate the NDC coordinates to make the image
  // draw within the correct area.
  const Vec2 ndcScale(2.0f / static_cast<float>(width), 2.0f / static_cast<float>(height));
  auto ndcRectScaled =
      Rect::MakeXYWH(srcProjectRect.left * ndcScale.x, srcProjectRect.top * ndcScale.y,
                     srcProjectRect.width() * ndcScale.x, srcProjectRect.height() * ndcScale.y);
  const Vec2 ndcOffset(-1.f - ndcRectScaled.left + 2 * x / static_cast<float>(width),
                       -1.f - ndcRectScaled.top + 2 * y / static_cast<float>(height));

  auto allocator = context->drawingAllocator();
  // Disable anti-aliasing for small images to avoid large semi-transparent areas when small
  // rectangles are projected as large ones.
  auto vertexProvider =
      RectsVertexProvider::MakeFrom(allocator, srcModelRect, AAType::MSAA, Color(1, 1, 1, alpha));
  const Size viewportSize(static_cast<float>(width), static_cast<float>(height));
  const Rect3DDrawArgs drawArgs{matrix, ndcScale, ndcOffset, viewportSize};
  auto drawOp = Rect3DDrawOp::Make(context, std::move(vertexProvider), 0, drawArgs);
  const SamplingArgs samplingArgs = {TileMode::Clamp, TileMode::Clamp, {}, SrcRectConstraint::Fast};
  const TPArgs args(context, 0, false, 1.0f);
  auto sourceTextureProxy = image->lockTextureProxy(args);
  // Ensure the vertex texture sampling coordinates are in the range [0, 1]
  DEBUG_ASSERT(srcW > 0 && srcH > 0);
  // The Size obtained from Source is the original size, while the texture size generated by Source
  // is the size after applying DrawScale. Texture sampling requires corresponding scaling.
  auto uvMatrix = Matrix::MakeScale(static_cast<float>(sourceTextureProxy->width()) / srcW,
                                    static_cast<float>(sourceTextureProxy->height()) / srcH);
  auto fragmentProcessor =
      TextureEffect::Make(allocator, std::move(sourceTextureProxy), samplingArgs, &uvMatrix);
  drawOp->addColorFP(std::move(fragmentProcessor));
  drawOp->setEnableDepthTest(true);
  // Transparent pixels should not overwrite the depth buffer, otherwise they would cause
  // underlying pixels to become invisible.
  drawOp->setEnableDepthWrite(FloatNearlyEqual(alpha, 1.0f));
  drawOps.emplace_back(std::move(drawOp));
}

std::shared_ptr<Image> Context3DCompositor::finish() {
  auto context = targetColorProxy->getContext();
  DEBUG_ASSERT(context != nullptr);

  auto opArray = context->drawingAllocator()->makeArray(std::move(drawOps));
  context->drawingManager()->addOpsRenderTask(targetColorProxy, targetDepthStencilProxy,
                                              std::move(opArray), PMColor::Transparent());
  auto image = TextureImage::Wrap(targetColorProxy->asTextureProxy(), ColorSpace::SRGB());
  targetColorProxy = nullptr;
  targetDepthStencilProxy = nullptr;
  return image;
}

}  // namespace tgfx